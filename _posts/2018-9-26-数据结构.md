--- 
layout: post
title: 数据结构
date: 2018-9-26
tags: java
---
### **时间复杂度**
运行次数而非时间（因为不同机器的运行环境不同）
### **空间复杂度**
占用内存大小
### **程序的难易程度**
能否一读便通
### **健壮性**
能处理各种非法异常
字段表示一个事物的属性（列） 
记录表示一个事物（行） 
表是同一类事物的集合 
视图是为了简化查询 
程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言
### **用链表实现栈**
``` 
class Node<E> {
     Node<E>next=null;
     E data;
     public Node(E data) {this.data=data;}
}

public class Stack<E> {
    Node<E>top=null;
    public boolean isEmpty() {
        return top==null;
    }
    /*新建一个结点，该节点指向当前的头结点
     *再修改top指向新建的结点*/
    public void push(E data) {
        Node<E>newNode=new Node<E>(data);
        newNode.next=top;
        top=newNode;
    }
    /*
     * 将当前的top结点的值保存到data
     * 再把top的指针指向下一个结点*/
    public E pop() {
        if(isEmpty())
            return null;
        E data=top.data;
        top=top.next;
        return data;
    }
    public E peek() {
        if(isEmpty()) {
            return null;
        }
        return top.data;
    }
}
```
### **数组实现栈**

``` 
import java.util.Arrays;

public class Mystack<E>{

        private Object[] stack;
        private int size;

        public Mystack() {
            stack=new Object[10];
        }

        public boolean isEmpty() {
            return size==0;
        }

        public E peek() {
            if(isEmpty()) {
                return null;
            }
            return(E) stack[size-1];
        }

        public E pop() {
            E e=peek();
            stack[size-1]=null;
            size--;
            return e;
        }

        public E push(E item) {
            ensureCapacity(size+1);
            stack[size++]=item;
            return item;
        }

        private void ensureCapacity(int size) {
            int len=stack.length;
            if(size>len) {
                int newLen=10;
                stack=Arrays.copyOf(stack,newLen);
            }
        }
}
```
###  **排序问题**
![enter description here](https://viabcde.github.io/images/2018-09-21/排序.png)
 对于不同情况，即需要排序的数据的大小n  
 当n较小时直接使用选择或插入排序  
 若数据大部分有序的可以选择冒泡或快速排序  
 但是，要判断是否基本有序的标准很难拿捏，所以...
 当n较大时，可以选择堆排序和归并排序等因为它们的时间复杂度为nlogn，从数学的角度来讲，n越大，其递增的速度比n^2慢  
快些选堆不稳定   
记忆：堆在北方的方言是坟墓的意思，不慎重考虑，快些选坟墓就不稳定，可能会诈尸！即使2个数是一样的，它还是会做一遍排序操作  


