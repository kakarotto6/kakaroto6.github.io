--- 
layout: post
title: 序列化与反序列化
date: 2018-11-15
tags: java
---
### **序列化与反序列化**
### **实体类实现序列化**
需要比较是否已有重复的数据  
先比较首地址是否相同(hashcode)   相同不能存入    
不同再比较内容是否相同（equals）   
**序列化** (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。  
一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。    
在网络传输过程中，可以是字节或是XML等格式。  
**反序列化**：由字节的或XML编码格式可以还原完全相等的对象。   
### **为什么使用序列化**
在Java中，可多种方式来创建对象，只要对象没被回收都可以复用它。   
这些Java对象都是存在于JVM的堆内存中，只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。  
在真实的应用场景中，需要将对象持久化，在需要时把对象重新读取出来。Java的对象序列化可实现该功能。
### **重写equals方法时为什么要同时重写Hashcode方法**
首先equals与hashcode间的关系是这样的： 
如果两个对象相同（即用equals比较返回true），那么它们的hashCode值必定要相同，但hashCode相同的不一定equals；

为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没必要再进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用；

我们都知道java中的List集合是有序的，因此是可以重复的，而set集合是无序的，因此是不能重复的，那么怎么能保证不能被放入重复的元素呢，但靠equals方法一样比较的话，如果原来集合中以后又10000个元素了，那么放入10001个元素，难道要将前面的所有元素都进行比较，看看是否有重复，欧码噶的，这个效率可想而知，因此hashcode就应遇而生了，java就采用了hash表，利用哈希算法（也叫散列算法），就是将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。
