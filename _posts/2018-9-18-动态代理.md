---   
layout: post  
title: 动态代理
date: 2018-09-18  
tags: 动态代理 
---
## **使用代理的原因**
### **原因**
1.把业务代码和系统控制层代码分离，降低类的耦合度。
2.在原来的代码上修改代码还不如自己直接重写快。  
**因此产生了静态代理**    
### **静态代理**
通过被代理类注入的方式，实现既可以使用增强逻辑，又可以通过类名.方法调用被代理类的方法  
``` 
增强：             System.out.println("do some log");
被代理类的方法：        被代理类类名.方法();
增强：　　　　          System.out.println(method);
```
解决了代码间的强耦合。   
但缺点在于重复代码过多，eg.当接口增加了方法，代理类也必须增加方法，同时之前写的日志等代理逻辑仍需要在新增的方法重写一遍。（所以适用于小的系统）
**因此产生了动态代理**
### **动态代理解决了以上的不足**
动态代理实现了在运行时动态对指定的方法进行绑定，然后在代理类执行增强的逻辑和通过反射机制（invoke）调用被代理类的方法

``` 
增强：             System.out.println("do some log");
被代理类的方法：        method.invoke(target, args);
增强：　　　　          System.out.println(method);
```
解决了静态代理把需要代理的方法写死在代理类中的问题
### **动态代理又分两种**
一种是代理哪些有接口的类 这种动态代理是基于JDK的动态代理  
另一种是代理那些没有接口的类 这种动态代理是基于cglib的动态代理  
它们都不会自己去调用被代理对象的方法，而是交由第三方去invoke

[源代码](https://github.com/viabcde/mycoding.github.io/tree/master/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86)  

### **有接口的动态代理**
被代理类至少实现一个接口
**创建代理对象的方法：**     
ClassLoader:和被代理对象使用相同的类加载器  
Class[]：字节码数组，被代理类实现的接口  
InvocationHandler：写增强代码要实现的接口
``` 
new ProxyInstance(ClassLoader,Class[],InvocationHandler)
```

``` 
package proxy;
public class Actor implements IActor {
	@Override
	public void basicAct(float money){
		System.out.println("1W只能基本表演"+money);
	}
	@Override
	public void DangerAct(float money){
		System.out.println("5w危险表演"+money);
	}
}
```
``` 
package proxy;
public interface IActor {
	public abstract void basicAct(float money);
	public abstract void DangerAct(float money);
}
```
```
package proxy;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class Client {
	/**
	 * @param args
	 */
	public static void main(String[] args) {	
		final IActor actor =new Actor();
		IActor proxyActor = (IActor)Proxy.newProxyInstance(actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), 
				new InvocationHandler() {					
					@Override
					public Object invoke(Object proxy, Method method, Object[] args)
							throws Throwable {
					    Object ReturnValue = null;
						Float money=(Float) args[0];
						if("basicAct".equals(method.getName())){
							if(money>10000){
								ReturnValue = method.invoke(actor, money/2);
							}
						}
						if("DangerAct".equals(method.getName())){
							if(money>50000){
								ReturnValue = method.invoke(actor, money/3);
							}
						}
						return ReturnValue;
					}
				});
		proxyActor.basicAct(20000);
		proxyActor.DangerAct(60000);	
	}
}

```

### **无接口的动态代理**
要求：被代理类不能是Final修饰的类  
创建代理对象的方法：  
create(Class,Callback)  
Class:被代理对象的字节码  
Callback:实现该接口的子接口MethodInterceptor
![](https://viabcde.github.io/images/2018-09-17/spring7.png)    

``` 
package proxyExtend;
public class Actor  {
	public void basicAct(float money){
		System.out.println("1W只能基本表演"+money);
	}
	public void DangerAct(float money){
		System.out.println("5w危险表演"+money);
	}
}
```
``` 
package proxyExtend;
import java.lang.reflect.Method;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
public class Client {
	/**
	 * @param args
	 */
	public static void main(String[] args) {		
		final Actor actor =new Actor();
		Actor proxyActor = (Actor)Enhancer.create(actor.getClass(), 
					new MethodInterceptor() {						
						@Override
						public Object intercept(Object proxy, Method method, Object[] args,
								MethodProxy methodproxy) throws Throwable {
						    Object ReturnValue = null;
							Float money=(Float) args[0];
							if("basicAct".equals(method.getName())){
								if(money>10000){
									ReturnValue = method.invoke(actor, money/2);
								}
							}
							if("DangerAct".equals(method.getName())){
								if(money>50000){
									ReturnValue = method.invoke(actor, money/3);
								}
							}
							return ReturnValue;
						}
					});
		proxyActor.basicAct(20000);
		proxyActor.DangerAct(60000);		
	}
}
```

