--- 
layout: post
title: java基础知识
date: 2018-9-26
tags: 基础
---
### **反码 取反 补码**
1.反码是指符号位不变 其他位改变 符号位1为负 0为正  
2.取反是指所有位都改变  
3.正数的补码与原码相同 无需改变 , 而负数的补码是 取绝对值 取反 再加1  
反过来由补码获取原码 减1 取反 取绝对值  
4.计算机运算都是以补码来运算 如 ~ 2 和 ~-2 都是对补码的取反 而不是原码  
### **数据类型**
一个字节（byte）=8位 有2的8次方种可能 范围-128~127 负0（1000 0000）表示-128 正0（0000 0000）表示0  
以此类推 short = 2个字节 2*8（位） int 4个字节 long 8个字节  
### **字符相加**
字符相加是指其对于的ASCII码相加后 在ASCII表中对应的字符 如果没有对应的 即打印一个 ？
###  **强制转换为int**
在强转为int时，只保留整数部分 小数部分无论多少都舍去 没有四舍五入的操作
### **从控制台读取输入的内容**
使用InputStreamReader 读取控制台的内容（system.in）
再使用BufferReader 读取InputStrreamReader的内容 之后由BufferReader调用readLine()输出给一个引用变量（String s = br.readLine()）
inputStreamReader外面包一层BufferReader
```
/*从控制台读取输入内容*/
		try {
			InputStreamReader isr = new InputStreamReader(System.in);
			BufferedReader br = new BufferedReader(isr);
			String a = bd.readLine();
		} catch (Exception e) {
			// TODO: handle exception
		}

```
或

``` 
Scanner sc = new Scanner(system.in);
String s=sc.nextInt();
```

### **String转为float**
Float f = float.parseFloat(a);
### **打印菱形**
先使用一个for 控制输出多少行  
	再在里面嵌套2个for   
	第一个for控制每一行里先输出多少个空格  
	第二个for控制空格之后输出多少个星号“*”  
		在第二个for中使用if判断是否是第一列和最后一列 输出星号“*”  
			否则输出空格  
### **何时会被当成垃圾回收**
当指针不再指向该数据时会被当成垃圾等待回收  
当内存即将不够用的时候，GC会遍历一遍对象，没有被遍历到的对象会被清除  
### **默认构造方法**  
每个对象都会有一个默认的空构造方法  
public person(){}  
如果自己写了构造方法 则默认的构造方法会被覆盖   
要使用空构造方法则需要显式写出来 才能使用  
### **this**
JVM为每个对象都提供了一个this 代表对象本身  
this.name 相当于 对象说了一句 我的name  
在构造方法中也可以不用this 改用对象的属性 名来为属性赋值   
但这样一来程序的可读性下降   
### **静态变量**
也称为类变量，因为它是属于类的而不是实例对象的，通过类名.变量来使用它  
例子：static int a=1;
### **静态方法** 
静态方法在类编译完就会执行 而且只执行一次属于类而不是实例对象的   
静态方法不能访问非静态变量 因为静态方法编译后，在类装载时初始化存在内存中，而非静态变量在编译后不存在内存中（只有在new之后才加入到内存），根本就找不到该变量，访问不到 执行顺序：类加载->main  
### **访问权限**
记忆很简单 画一个4*4矩阵  范围依次递减 √ 即可
|    范围|同类 | 同包|子类|不同包    |  
| --- | --- | --- | --- | --- |  
|     public   | √| √|√|√    |  
|protected|√ | √|√|
  |default  |√| √|
  |private  |√ |
  
### **package的作用**
将源文件的字节码打包到同一个包中  
### **继承**
将共有的属性及方法提取出来组成一个父类  
子类可以访问父类的属性及方法，但不能访问父类的private属性 方法 和缩小父类的访问权限  
### **super.f()**
指的是调用父类的f方法  
子类的构造必须先调用父类的构造方法super()   通过参数列表的不同指明调用父类的哪个构造方法  
因为子类需要用到父类的属性和方法 所以必须先把父类构造出来才能用  
如果没写 系统默认使用父类空的构造方法
### **方法重载**
方法名相同 参数列表不同构成重载  
仅返回类型不同不能构成重载
### **多态**
可以创建相同父类类型的不同子类对象  
这样在写构造方法时 不需要按不同子类类型写多个重载方法  
可以创建相同接口类型的不同接口实现类
### **动态绑定（迟邦定） 多态**
 在编译时指向的是父类的内存 而运行时   方法实际传入的是哪个子类便更改指向父类的指针为指向子类的内存   把子类当做父类使用 即向上转型
### **抽象类**
抽象是将某一类事务归类的研究方法（抽象是一种研究的方法）  
当父类方法的逻辑很大概率会被子类覆盖重写时 可以将父类定义为抽象类  
子类必须实现父类的所有抽象方法  
接口是更加抽象的抽象类 接口中的变量默认是static final类型  
抽象类是对一类事物的抽象 而接口是对一个功能的抽象  
static final 前期绑定  
多态 后期绑定  
 **当子类不想实现父类抽象方法时 ，则可以在写一个同名的抽象方法即可不用实现**   
### **接口不能代替抽象类**
因为如果需要维护一个类的信息和状态时需要用到实例成员变量（没有static修饰）
而接口中的变量都用 static final修饰
### **封装**
将数据保护起来，外部只能通过被授权的操作才能访问  

### **符号运算**
左移<<右侧补0
右移>>左侧补符号位
### **ArrayList与Vector区别**
ArrayList用于异步 容量不足自动扩展为原来的1.5倍 
Vector用于同步 容量不足自动扩展为原来的2倍
### **遍历HashMap**
iterator.next来获取key  
通过get(key)获取Value
![enter description
here](https://viabcde.github.io/images/2018-09-26/2018092601.png)  
### **HashMap与HashTable区别**
HashMap用于异步 其key与value 可以为空
HashTable用于同步 其key与value 不可以为空 编译时不报错 运行时出错
### **hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？**
在put方法里头，其实第一行就处理了key=null的情况。 

``` 

if (key == null)  
    return putForNullKey(value);  
//那就看看这个putForNullKey是怎么处理的吧。  
private V putForNullKey(V value) {  
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {  
        if (e.key == null) {  
            V oldValue = e.value;  
            e.value = value;  
            e.recordAccess(this);  
            return oldValue;  
        }  
    }  
    modCount++;  
    addEntry(0, null, value, 0);  
    return null;  
} 
```
可以看到，前面那个for循环，是在talbe[0]链表中查找key为null的元素，如果找到，则将value重新赋值给这个元素的value，并返回原来的value。
如果上面for循环没找到则将这个元素添加到talbe[0]链表的表头。 
### **泛型**

``` 
泛型Generic  
起因：  
    ·JDK1.4以前类型不明确：  
        ·装入集合的类型都被当作Object对待，从而失去自己的实际类型  
        ·从集合中取出时往往需要转型，效率低，容易产生错误  
解决办法  
    ·在定义集合的时候同时定义集合中对象的类型  
    ·实例：  
        ·可以再定义Collection的时候指定  
        ·也可以在循环时用Iterator指定  
    List<String> c = arrayList<String>();  
    Iterator<String> it = c2.iterator();  
好处  
    ·增强程序的可读性和稳定性  
```
 
定义一个SeqList< T >类   
在创建实例时可以自定义元素类型 ，如  
SeqList< String > a =new SeqList< String >();  
SeqList< Integer > a =new SeqList< Integer >();  
**优点：**不使用泛型 则从list取出来的元素是Object，需要做强制转换  
如果此时转换的类型与元素期望的类型不符 编译时不报错 运行时报错  
使用泛型 则不需要强制转换 如果创建与元素期望不符的类型 编译时报错提醒  
**缺点：**仍然可以使用反射机制来加入不同类型的元素  
collection.getClass().getMethod("add",Object.class).invoke(collection1,"aaa");  
### **finally**
文件如果不调用close()方法则数据并不会存入文件  
在finally中关闭文件 连接等操作 防止内存泄漏    
### **final**
因为final是常量 不会改变，所以对它进行优化 ，在编译阶段就使用它 而static真正使用是在运行时才能使用
### **不同try用throws**
报错时不知道错误发生在哪一行
### **冒泡排序**
在剩下的元素中比较出最大/小	的，放在最后
```
for(int i=0;i<a.length-1;i++){
	for(int j=0;j<a.length-1-i;j++){
		if(a[j]>a[j+1]){
			temp=a[j];
			a[j]=a[j+1];
			a[j+1]=temp;
		}
	}
}
```
### **选择排序**
从第一个元素开始通过和剩下的元素比较大小为每一个元素定好位，及最终排好序的位置
```
for(int i=0;i<a.length-1;i++){
	int min=a[i];
	int index=i;
	for(int j=i+1;j<a.length,j++){
		if(min>a[j]){
			min=a[j];
			index=j;
		}
	}
	temp=a[i];
	a[i]=a[j];
	a[index]=temp;
}
```
### **插入排序**

```
for(int i=1;i<a.length;i++){
	int insertVal=a[i];
	int index=i-1;
	while(index>=0&&insertVal>a[index]){
		a[index+1]=a[index];
		index--;
	}
	a[index+1]=insertVal;
}
```
### **JVM内存管理(内存空间、内存分配、内存回收)**
当内存空间即将用完，GC就会暂停程序，遍历所有对象并标记为1，没有被标记（及没被遍历到）的对象清除掉，最后再把所有被标记的全部置0
### **那为什么要暂停来垃圾回收**
因为如果在标记完成，清除没被标记的对象期间，所有在这个期间new出来的对象都会被误删
### **绝对值**
math.abs();
### **awt与Swing**
awt 会随系统而改变样式，Swing不会 但却消耗内存
### **JFrame**
j.serTitle();  
j.setSize();  
j.setLocation();  
j.setVisival();  
j.setDefaultColseOperation(JFram_Exit_IN);  
### **边界布局**
borderLayout 东西南北中
### **流式布局**
FlowLayout 随窗口排列
### **静态导入**
import static 则在类中不需要使用类名.方法名调用方法 只需用方法名即可
### **增强的for循环**
for(int i : args){}
### **装箱、拆箱**
Integer i=1; 将int类型的 1 装箱为Integer  
syso(i+3);将Integer类型的i 拆箱为int 之后与3相加
### **享 元模式**
把程序共有的部分封装为一个方法 而不同的部分作为方法的参数传入
### **获取字节码的方法**
String s="aaa";  
1.String.getClass();  
2.s.getClass();  
3.ClassforName("java.lang.String");
### **获取类的构造方法**
s.getClass().getConstructor();
### **获取类的属性**
s.getClass().getFiled
### **i++和++i**
在赋值时有区别 但在for循环中只是自加的作用 没有区别 据说++i比i++快一些
### **数组**
数组变量中存了数组第一个元素的首地址、数组的容量，一级有效个数  
当需要取出第二个元素时，第二个元素首地址=第一个元素首地址+1
### **java内存泄漏情况**
忘记关闭数据库连接 忘记删除监听器 没有及时将对象设为null
### **equals和==**
equals表示内容相同 首地址不一定相同  
而“==”表示首地址相同 此时 内容肯定也相同
### **ip和端口**
ip表示网络中的主机 端口表示主机上的程序
### **数据类型相加**
1.int型以下(byte short 还有char)作为操作数，jvm会将其类型提升至int   再参与运算；int型以上保持原有类型
2.表达式返回值的类型会提升至操作符两边表数范围较大的那一方的类型




### **instanceof 判断一个对象是否属于某个类的示例**

```
public class Test_instanceof {

	public static void main(String[] args) {
		String s = "Hello";
		int[] a = {1,2};
		if(s instanceof String)
			System.out.println("true");
		if(s instanceof Object)
			System.out.println("true");
		if(a instanceof int[])
			System.out.println("true");
	}
}
```
### **继承** 
是子类和父类之间的关系 即把各个子类的公共属性提取出来作为父类
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092703.png) 
### **return** 
返回的值 会临时保存在栈内存中 方法结束后该内存才消失
###  **equals方法默认比较的是首地址 必须重写**
String类 已经重写了equals方法 所以用String 比较时 不用自己重写equals方法  
### **局部变量系统不会自动初始化 成员变量才会**
### **new String(c,4,3);**
从c 的第4个字符串开始截取3个字符
### **s.indexof(“java”)** 
首次出现java 的第一个位置
### **String[] _split= s.split(“,”);**
 把s 按逗号分离并分别保存到数组中_split
 
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092706.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092707.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092708.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092729.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092710.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092711.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092712.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092713.png)
区别 ：前者是动态绑定 即编译期间 d指向的是Object 的toString 方法  
运行时d 指向的是传入的子类对象 的toString方法  
而后者直接调用d的toString方法  
### **判断c是否小写**
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092714.png)
s.charAt(i) 取得s 第i-1个字符  
s.subString(1,2);表示截取 第2到第3个字符  
s.subString(2);表示截取第3个字符至结尾所有字符  
s1+=s2 指的是 s1 s2   的内存都复制保存到第三个内存空间中（因为String是不可变的   所以只能把2个String复制到共同的内存空间） 再把s1的首地址指向第三个内存空间
效率较低 改进 用StringBuffer  
枚举类型 规定只能选择使用的参数时哪几个 使用类名.属性来获取   比如游戏中定义方向只能上下左右四个方向  
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092715.png)
用容器的原因  
数组的长度不能增加 要扩展必须开辟另一空间 再把原来的数组复制过来  
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092716.png)
使用多态的原因 因为c只能使用Collection接口中的方法   而不会使用子类ArrayList自己的方法  
当更换子类LinkList时 不需要修改子类的自己方法 直接替换即可  
这里的Name类没有重写equals方法 所以其equals方法比较的是首地址是否相同   
很明显2个Name对象都是各自new 出来的 首地址不同 所以   remove时并不会把之前的Name对象移除  
 ![enter description here](https://viabcde.github.io/images/2018-09-27/2018092717.png)
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092718.png)  
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092719.png)
utf8比较省空间  
join 即把线程归并回主线程 当做方法使用   只有该线程执行完后才继续执行它下面的代码    
yield 当前线程让其他线程执行一会  
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092720.png)
网关 一边连着子网 替子网转发 一边连着公网上网  
TCP必须有回复才发  
UDP 发了不管    
## **继承**
 ![enter description here](https://viabcde.github.io/images/blog/2018092801.png)
## **接口实现**
 ![enter description here](https://viabcde.github.io/images/blog/2018092802.png)
## **关联 即A中引用了B**
!![enter description here](https://viabcde.github.io/images/blog/2018092803.png)
## **聚合** 
![enter description here](https://viabcde.github.io/images/blog/2018092804.png)
## **组合 对于 自身属性**
![enter description here](https://viabcde.github.io/images/blog/2018092805.png)
## **依赖  对于传入方法参数**
![enter description here](https://viabcde.github.io/images/blog/2018092806.png)
## **为什么尽量不去改动已有的代码**  
一是为了防止有些程序员恶意破坏  
二是改了之后已有的代码还需要重新到各个机器编译安装一次  
## **连接字符串**
```
String s="a";
s=s.concat("b");
```
syso s=ab
### **生成随机数**
```
int x=(int)(Math.random()*100);
```
0-100  包括0 不包括100
### **毫秒**
System.currentTimeMillis()  获取当前时间并转为毫秒数
System.currentTimeMillis() /1000 获取当前时间并转为秒数
## **字符串常用的函数**
如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。
toCharArray() // 获得字符串对应的char数组
Arrays.sort() // 数组排序
Arrays.toString(char[] a) // 数组转成字符串
charAt(int x) // 获得某个索引处的字符
length() // 字符串长度
length // 数组大小
### **随机产生26个字母中的20个 可重复**
```
public Set getChar(){    
        Set numberSet01 = new HashSet();   
        Random rdm = new Random();   
        char ch;   
        while(numberSet01.size()<20){    
           int rdGet = Math.abs(rdm.nextInt())%26+97;//产生97到122的随机数a-z值   
            ch=(char)rdGet;   
            numberSet01.add(ch);   
            //Set中是不能放进重复的值的，当它有20个时，就满足你的条件了    
        }    
          return numberSet01;   
        }   
```
### **给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串** 
```
   public String date2FormatStr(Date date)   
    {    
      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    
      String str = sdf.format(date);    
      return str;    
    }   
```
### **判断是否是一个数的因子**

  //如果余数为0说明 该除数是被除数的因子
             if(i % j==0)

### **弹出对话框并从中获取用户输入的值保存到str中**
String str=javax.swing.JOptionPane.showInputDialog("请输入N的值（输入exit退出）：");
//用到str的时候可以转换为相应的类型 如
int N=Integer.parseInt(str);