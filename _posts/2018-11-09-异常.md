--- 
layout: post
title: 异常
date: 2018-11-12
tags: 异常
---
### **异常**
异常分为ERROR和Exception    
Error 环境问题 计算机问题     
Exceprion包括运行时异常（数组越界等）和编译异常（语法错误）
运行异常 如IOException    编译异常 语法错误  
**除了虚拟机给我们抛出的异常外，有时还需要程序员自己主动抛异常**       
如在一个用户交互的环境下，想知道是哪个用户的输入导致了异常，这个时候系统产生的异常堆栈信息就不能满足我们的要求了，而这个信息在当前类的一个字段中，这时候我们就要主动捕获然后打印出我们想要的。
### **解决异常的常用方法思路**
1.写个再试执行一次的代码  
2.修饰错误页面为友好的错误提示  
3.用try/catch捕获手工错误的异常
 **1.对于偶发异常 使用重复尝试**  
例如：当前Socket连接不可用（长时间不用被服务器主动断开，或者网络抖动导致的断开），那么我们捕获这个异常，然后重新建立一个连接来发送。  
这是最基本的解决方法，再高级一点的就是设置一个重复次数，当出现异常的时候重复发送指定的次数。   
本质上并没有解决异常，而是解决了连接断开的问题
``` 
//有一个连接中的socket
Socket socket=...
//要发送的数据
String data="";
try{
    socket.write(data);
}catch (Excetption e){
    //打印日志，并重连Socket
    socket=new Socket(host,port);
    socket.write(data);
}
```
### **2.不想让用户看到堆栈 影响用户体验**
用一个最大的try catch包住一个个方法，当出现异常的时候跳转到友好的错误页面。
本质上也没有解决异常，而是用try/catch吞掉了
``` 
public String method(String param){
  try {
    //逻辑处理
  } catch (Exception e) {
    e.printStackTrace();
    //跳转到错误页面
  }
}
```
### **对于一定不会出现的异常**

``` 
import java.io.UnsupportedEncodingException;
public class Utils {
  public static String utf8(byte[] bytes) throws UnsupportedEncodingException{
    return new String(bytes,"UTF-8");
  }
  public static byte[] utf8(String str) throws UnsupportedEncodingException{
    return str.getBytes("UTF-8");
  }
}
```
就使用try/catch吞了，并打印异常信息，因为可能出现人为输入错误  
修改如下：  
``` 
public static String utf8(byte[] bytes){
  try {
    return new String(bytes,"UFO-8");
  } catch (UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  return null;
}
```

