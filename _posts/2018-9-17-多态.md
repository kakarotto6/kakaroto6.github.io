---   
layout: post  
title: 多态的应用（工厂模式）  
date: 2018-09-17  
tags: java  

---
### **运用多态**
**作用：**可以根据需要切换子类即面向接口编程，如果使用配置文件那么连源代码都不需要改;  
因为父类拥有所有子类的共有的方法，可以替换子类更改方法的实现方式
eg.切换不同的容器 Collection c= new ArrayList();  
比较不确定对象的大小或属性 该对象先得实现compare接口;  
![duotai](https://viabcde.github.io/images/2018-09-17/多态1.png)    
然后在比较的方法里运用多态的思想 用接口类型来比较对象的大小  
![duotai2](https://viabcde.github.io/images/2018-09-17/多态2.png)  
第1处多态：根据传入的不同类型的对象比较大小      
第2处多态：在比较大小时，比较方式定义为接口，利用多态思想传入不同的比较策略      
**总结：**策略模式就是运用接口多态的思想只需要把固定的策略作为接口并写在源代码里，而接口的实现作为参数传入的，当需要变更策略（即接口算法的实现）时只需要替换实现类即可 不需要修改源代码    
### **示例代码：**  
**测试类**
``` 
public class Test {
	public static void main(String[] args) {
		//int[] a = {9, 5, 3, 7, 1};
		//Cat[] a = {new Cat(5, 5), new Cat(3, 3), new Cat(1, 1)};
		Dog[] a = {new Dog(5), new Dog(3), new Dog(1)};
		DataSorter.p(a);
		System.out.println();
		DataSorter.sort(a);
		//java.util.Arrays.sort(a);
		DataSorter.p(a);
	}
}
```
**接口**

``` 
public interface Comparable {
	public int compareTo(Object o);
}
```
**面向接口编码**

``` 
public class DataSorter {

	public static void sort(Object[] a) {
		for(int i=a.length; i>0; i--) {
			for(int j=0; j<i-1; j++) {
				Comparable o1 = (Comparable)a[j];
				Comparable o2 = (Comparable)a[j+1];
				if(o1.compareTo(o2) == 1) {
					swap(a, j , j+1);
				}
			}
		}
	}
	
	
	
	private static void swap(Object[] a, int x, int y) {
		Object temp = a[x];
		a[x] = a[y];
		a[y] = temp;
	}

	public static void sort(int[] a) {
		for(int i=a.length; i>0; i--) {
			for(int j=0; j<i-1; j++) {
				if(a[j] > a[j+1]) {
					swap(a, j , j+1);
				}
			}
		}
	}

	private static void swap(int[] a, int x, int y) {
		int temp = a[x];
		a[x] = a[y];
		a[y] = temp;
	}

	public static void p(int[] a) {
		for(int i=0; i<a.length; i++) {
			System.out.print(a[i] + " ");
		}
		System.out.println();
	}

	public static void p(Object[] a) {
		for(int i=0; i<a.length; i++) {
			System.out.print(a[i] + " ");
		}
		System.out.println();
	}

}
```

**任何实现接口的类都能比较**

``` 
public class Dog implements Comparable {
	public Dog(int food) {
		super();
		this.food = food;
	}

	private int food;

	public int getFood() {
		return food;
	}

	public void setFood(int food) {
		this.food = food;
	}

	@Override
	public int compareTo(Object o) {
		Dog d = (Dog)o;
		if(this.food > d.getFood()) return 1;
		else if(this.food < d.getFood()) return -1;
		else return 0;
	}
	
	@Override
	public String toString() {
		return this.food + "";
	}
}

```

### 获得当前的时间戳
![shijianchuo](https://viabcde.github.io/images/2018-09-17/获取当前的时间戳.png)
### 单例：
在对象的类里面 用静态方法new 对象本身 再通过暴露 getInstance的这个方法去让其他类获取这个对象 从而实现单例  
![danli](https://viabcde.github.io/images/2018-09-17/单例.png)  
### 工厂模式  
![dai](https://viabcde.github.io/images/all/2018092901.png)  
通过工厂来实现对象的管理与创建 ：
因为父类拥有所有子类的公共方法，通过父类来调用方法可以在替换子类时只需替换即可，不需要改代码
![gongchanmoshi](https://viabcde.github.io/images/2018-09-17/工厂模式.png)  

这样当子类更替的时候只需要修改一处即可不需要多处修改  
并且 子类也可以运用多态的思想创建相同父类类型的不同子类对象  
运用多态，通过继承抽象工厂来实现工厂的管理与创建 可以创建相同抽象工厂类型的不同子类对象
### 简单工厂与抽象工厂对比
### 简单工厂  
只是对类的管理 用来产生多个对象   
优点：增加扩展工厂的产品对象容易，只需直接增加  
缺点：相同系列的子类实现要修改时还要在产生一个新的工厂
### 抽象工厂  
则运用了多态的思想 可以创建相同抽象工厂类型的子类对象  
优点：解决了简单工厂的缺点   
缺点：扩展工厂的产品困难 ，需要在每一个系列的工厂都增加
 
