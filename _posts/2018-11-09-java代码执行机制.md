--- 
layout: post
title: java代码执行机制
date: 2018-11-15
tags: java
---
### **java代码执行机制**
**源代码编译机制**
第一步：  1.分析和输入到符号表（Parse and Enter）Parse  过程所做的是词法和语法分析 Enter  过程是将符号输入到符号表  
第二步：将annotation生成附加的代码  
第三步：语法分析后生产class文件，此时class文件可以放入jvm中执行  
**类加载与执行机制**
第一步：加载class，标记已加载的class  
第二步：校验class格式，初始化静态变量和静态方法  
第三步：当执行main方法时，执行静态变量和方法，若有new 则初始化其他类，在执行该类的方法调用  
当执行某个class时，先从下往上（Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器），然后再从上往下判断哪个加载器有该class,有则停止判断，使用该class  
执行顺序：
静态方法等 父类静态，子类静态，main 实例对象的方法块 实例对象的构造方法
``` 
public class Demo
{
    public int j = 10;
	public static int i = 0;  //静态成员
	//静态块    用于对静态成员初始化
	static
	{
		i=50;
		System.out.println("1、静态块1...");
	}
	//静态块    用于对静态成员初始化
	static
	{
		i=100;
		System.out.println("2、静态块2...");
	}
	public Demo()
	{
		System.out.println("3、构造方法...");
		j=10;
	}	
	//实例块 在构造方法前执行一般也用于初始化成员变量
	{
		j=90;
		System.out.println("4、实例块2...");
	}
	
	//实例块 在构造方法前执行一般也用于初始化成员变量
	{
		j=20;
		System.out.println("5、实例块2...");
	}
	
	public static void main(String args[])
	{
		System.out.println("6、main方法开始---i="+i);
		Demo d=new Demo();
	}
}
```
执行结果是1、2、6、4、5、3
### **程序执行过程**
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092704.png)  
### **栈区、堆区、代码区**
方法区：存储class的所有变量及方法等静态数据  
方法栈：存储各种基本数据对象和自定义对象的引用  
方法堆：存储所有实例出来的对象的内存  
