--- 
layout: post
title: 编程题
date: 2018-9-26
tags: java
---
### 求二进制中1的个数  

先普及一哈位逻辑运算符的知识  
|op1|op2|op1 & op2|  
|---|---|---|  
|0  |0  |0      |  
|0  |1  |0      |  
|1  |0  |0      |  
|1  |1  |1      |    
同为1时结果才为1  
|op1|op2|op1 I op2|  
|---|---|---|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|1|   
有1结果才为1  
|op1|op2|op1 ^ op2|  
|---|---|---|
|0  |0  |0      |  
|0  |1  |1      |  
|1  |0  |1      |  
|1  |1  |0      | 
不同时结果才为1  
### 第一种方法
n&1的是意思 判断最后一位是否为1
```
public class Test{
	public static int countOne(int n) {
		int count=0;
		while(n>0) {
			if((n&1)==1)
				count++;
			n>>=1;
		}
		return count;
	} 
}
```
### 第二种

```
public class Test{
	public static int countOne(int n) {
		int count=0;
		while(n>0) {
			if(n!=0)
				n=n&(n-1);
				count++;
		}
		return count;
	} 
}
```

### 统计一行字符中有多少个单词
判断每个字符是否为空 空则count+1 不空则继续往后判断
```
public class Test_plus {
	public static int wordCount(String s) {
		int word=0;
		int count=0;
		for(int i=0;i<s.length();i++) {
			if(s.charAt(i)==' ')
				word=0;
			else if(word==0) {//非空格且 word不等于0则word设为1 
				word=1;
				count++;
			}
		}
		return count;
	}
}
```

### 判断一个数是否是2的n次方
### 方法1
从1即2^0 开始与n比较 相等则返回true  每次往左移一位 2^1 2^2依次比较
```
public class Test{
	public static boolean isPower(int n) {
		if(n<1)return false;
		int i=1;
		while(i<=n) {
			if(i==n)return true;
			i<<=1;
		}
		return false;
	}
}
```
### 方法2

```
public class Test{
	public static boolean isPower(int n) {
	if(n<1)return false;
	int m=n&(n-1);
	return m==0;
	}
}
```
###  不用比较运算得到2个数中的较大或较小的值
a+b加上差值 或减去差值 再除以2 妙不可言！牛批！
```
public class Test_plus {
	public static int max(int a,int b) {
		return (a+b+Math.abs(a-b))/2;
	}
	public static int min(int a,int b) {
		return(a+b-Math.abs(a-b))/2;
	}
}


```
### 移位运算实现最快乘法
```
public calss Muti{
//n表示左移的次数 ，用循环来控制左移 每次左移一次
	public static int powerN(int m,int n){
		for(int i=0;i<n;i++)
			m=m<<1;
			return m;
	}
	public static void main(String[] args){
		System.out.println("3 * 8 = "+powerN(3,3));
	}

}
```
### 古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？ 

程序分析：   兔子的规律为数列1,1,2,3,5,8,13,21.... 
因此，可以使用递归 除了前2个返回是1要单独写之外 从第3个开始递归 该位置的值等于其前2个的值加和

```
public class exp2{
    public static void main(String args[]){
        int i=0;
        math mymath = new math();
        for(i=1;i<=20;i++)
            System.out.println(mymath.f(i));
    }
 
}
class math
{
    public int f(int x)
    {
        if(x==1 || x==2)
            return 1;
        else
            return f(x-1)+f(x-2);
    }
}
```
### 打印出所有的 "水仙花数 "，所谓 "水仙花数 "是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 "水仙花数 "，因为153=1的三次方＋5的三次方＋3的三次方。 

1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。 
     取百位数 ：小数点后的数省略  i=x / 100;
 
  取十位数 ：先取余数再省略小数点后的数     j=(x % 100) /10;
 
 取个位数 ：      k=x % 10;
```
public class exp2{
 
    public static void main(String args[]){
 
       int i=0;
 
       math mymath = new math();
 
       for(i=100;i<=999;i++)
 
           if(mymath.shuixianhua(i)==true)
 
           System.out.println(i);
 
    }
 
}
 
class math
 
{
    public boolean shuixianhua(int x)
 
    {
 
       int i=0,j=0,k=0;
 
       i=x / 100;
 
       j=(x % 100) /10;
 
       k=x % 10;
 
       if(x==i*i*i+j*j*j+k*k*k)
 
          return true;
 
       else
 
          return false;
    }
 
}
```
### 将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。【不是很懂】

程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：

(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。

(2)如果n <> k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你,重复执行第一步。

(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。

```
public class exp2{
    public exp2(){}
    public void fengjie(int n){
        for(int i=2;i<=n/2;i++){
            if(n%i==0){
                System.out.print(i+"*");
                fengjie(n/i);
                }
        }
        System.out.print(n);
        System.exit(0);///不能少这句，否则结果会出错
        }
        public static void main(String[] args){
             String str="";
             exp2 c=new exp2();
             str=javax.swing.JOptionPane.showInputDialog("请输入N的值（输入exit退出）：");
             int N;
             N=0;
             try{
                     N=Integer.parseInt(str);
                     }catch(NumberFormatException e){
                         e.printStackTrace();
                         }
            System.out.print(N+"分解质因数："+N+"=");
            c.fengjie(N);
        }   
}
```
### 【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩> =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。

1.程序分析：(a> b)?a:b这是条件运算符的基本例子。

```
import javax.swing.*;
 
public class ex5 {
 
        public static void main(String[] args){
 
             String str="";
 
             str=JOptionPane.showInputDialog("请输入N的值（输入exit退出）：");
 
             int N;
 
             N=0;
 
             try{
 
                N=Integer.parseInt(str);
 
              }
 
             catch(NumberFormatException e){
 
                e.printStackTrace();
 
               }
 
             str=(N>90?"A":(N>60?"B":"C"));
 
             System.out.println(str);
 
        }  
 
}
```
### 输入两个正整数m和n，求其最大公约数和最小公倍数。 

1.程序分析：利用辗除法。 

```
最大公约数：
public class CommonDivisor{
    public static void main(String args[])
    {
        commonDivisor(24,32);
    }
    static int commonDivisor(int M, int N)
    {
        if(N<0||M<0)
        {
            System.out.println("ERROR!");
            return -1;
        }
        if(N==0)
        {
            System.out.println("the biggest common divisor is :"+M);
            return M;
        }
        return commonDivisor(N,M%N);
    }
}
最小公倍数和最大公约数：
import java.util.Scanner;
public class CandC
{
//下面的方法是求出最大公约数
public static int gcd(int m, int n) {
while (true) {
if ((m = m % n) == 0)
return n;
if ((n = n % m) == 0)
return m;
}
}
public static void main(String args[]) throws Exception
{
//取得输入值
//Scanner chin = new Scanner(System.in);
//int a = chin.nextInt(), b = chin.nextInt();
int a=23; int b=32;
int c = gcd(a, b);
System.out.println("最小公倍数：" + a * b / c + "\n最大公约数：" + c);
}
}
```
### 【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。 

1.程序分析：利用while语句,条件为输入的字符不为 '\n '. 
```
import java.util.Scanner;
public class ex7 {
     public static void main(String args[])
     {
      System.out.println("请输入字符串：");
      Scanner scan=new Scanner(System.in);
      String str=scan.next();
      String E1="[\u4e00-\u9fa5]";
      String E2="[a-zA-Z]";
      int countH=0;
      int countE=0;
      char[] arrChar=str.toCharArray();
      String[] arrStr=new String[arrChar.length];
      for (int i=0;i<arrChar.length ;i++ )
      {
       arrStr[i]=String.valueOf(arrChar[i]);
      }
      for (String i: arrStr )
      {
       if (i.matches(E1))
       {
        countH++;
       }
       if (i.matches(E2))
       {
        countE++;
       }
      }
      System.out.println("汉字的个数"+countH);
      System.out.println("字母的个数"+countE);
     }
    }
```
### 求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 
1.程序分析：关键是计算出每一项的值。 
```
import java.io.*;
public class Sumloop {
  public static void main(String[] args) throws IOException
  {
      int s=0;
      String output="";
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      System.out.println("请输入a的值");
      String input =stadin.readLine();
      for(int i =1;i<=Integer.parseInt(input);i++)
      {
          output+=input;
          int a=Integer.parseInt(output);
          s+=a;
      }
      System.out.println(s);
  }
}
另解:
import java.io.*;
public class Sumloop {
  public static void main(String[] args) throws IOException
  {
      int s=0;
      int n;
      int t=0;
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      String input = stadin.readLine();
      n=Integer.parseInt(input);
      for(int i=1;i<=n;i++){
       t=t*10+n;
       s=s+t;
       System.out.println(t);
      }
      System.out.println(s);
     }
}
```
### 一个数如果恰好等于它的因子之和，这个数就称为 "完数 "。例如6=1＋2＋3.编程   找出1000以内的所有完数。

```
public class Wanshu {
 public static void main(String[] args)
 {
     int s;
     for(int i=1;i<=1000;i++)
     {
         s=0;
         for(int j=1;j<i;j++)
         //如果余数为0说明 该除数是被除数的因子
             if(i % j==0)
                 s=s+j;
            if(s==i)
                System.out.print(i+" ");
     }
     System.out.println();
 }
}
```
### 一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？ 
```
public class Ex10 {
 public static void main(String[] args)
 {
     double s=0;
     double t=100;
     for(int i=1;i<=10;i++)
     {
         s+=t;
         t=t/2;
     }
     System.out.println(s);
     System.out.println(t);
      
 }
}
```
### 【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 

1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去   掉不满足条件的排列。

```
public class Wanshu {
 public static void main(String[] args) {
    int i=0;
    int j=0;
    int k=0;
    int t=0;
    for(i=1;i<=4;i++)
        for(j=1;j<=4;j++)
            for(k=1;k<=4;k++)
                if(i!=j && j!=k && i!=k)
                {t+=1;
                    System.out.println(i*100+j*10+k);
 } 
    System.out.println (t);
    }
}
```
### 企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？ 

1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 

```
import java .util.*;
public class test {
    public static void main (String[]args){
        double sum;//声明要储存的变量应发的奖金
        Scanner input =new Scanner (System.in);//导入扫描器
        System.out.print ("输入当月利润");
        double lirun=input .nextDouble();//从控制台录入利润
        if(lirun<=100000){
            sum=lirun*0.1;
        }else if (lirun<=200000){
            sum=10000+lirun*0.075;
        }else if (lirun<=400000){
            sum=17500+lirun*0.05;
        }else if (lirun<=600000){
            sum=lirun*0.03;
        }else if (lirun<=1000000){
            sum=lirun*0.015;
        } else{
            sum=lirun*0.01;
        }
        System.out.println("应发的奖金是"+sum);
        }
}
```
### 一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？ 

1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析： 

```
public class test {
    public static void main (String[]args){
    long k=0;
    for(k=1;k<=100000l;k++)
        if(Math.floor(Math.sqrt(k+100))==Math.sqrt(k+100) && Math.floor(Math.sqrt(k+168))==Math.sqrt(k+168))
            System.out.println(k);
    }
}
```
### 输入某年某月某日，判断这一天是这一年的第几天？ 

1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。 

```
import java.util.*;
public class test {
    public static void main (String[]args){
        int day=0;
        int month=0;
        int year=0;
        int sum=0;
        int leap;  
        System.out.print("请输入年,月,日\n");  
        Scanner input = new Scanner(System.in);
        year=input.nextInt();
        month=input.nextInt();
        day=input.nextInt();
        switch(month) /*先计算某月以前月份的总天数*/ 
        {  
        case 1:
            sum=0;break;  
        case 2:
            sum=31;break;  
        case 3:
            sum=59;break;  
        case 4:
            sum=90;break;  
        case 5:
            sum=120;break;  
        case 6:
            sum=151;break;  
        case 7:
            sum=181;break;  
        case 8:
            sum=212;break;  
        case 9:
            sum=243;break;  
        case 10:
            sum=273;break;  
        case 11:
            sum=304;break;  
        case 12:
            sum=334;break;  
        default:
            System.out.println("data error");break;
        }  
        sum=sum+day; /*再加上某天的天数*/ 
        if(year%400==0||(year%4==0&&year%100!=0))/*判断是不是闰年*/ 
            leap=1;  
        else 
            leap=0;  
        if(leap==1 && month>2)/*如果是闰年且月份大于2,总天数应该加一天*/ 
            sum++;  
        System.out.println("It is the the day:"+sum);
        }
}
```
### 输入三个整数x,y,z，请把这三个数由小到大输出。 

1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x> y则将x与y的值进行交换，然后再用x与z进行比较，如果x> z则将x与z的值进行交换，这样能使x最小

```
import java.util.*;
public class test {
    public static void main (String[]args){
        int i=0;
        int j=0;
        int k=0;
        int x=0;
        System.out.print("请输入三个数\n");  
        Scanner input = new Scanner(System.in);
        i=input.nextInt();
        j=input.nextInt();
        k=input.nextInt();
        if(i>j)
        {
          x=i;
          i=j;
          j=x;
        }
        if(i>k)
        {
          x=i;
          i=k;
          k=x;
        }
        if(j>k)
        {
          x=j;
          j=k;
          k=x;
        }
        System.out.println(i+", "+j+", "+k);
    }
}
```
### 输出9*9口诀。 

1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。

```
public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i<=9;i++)
    {   for(j=1;j<=9;j++)
            System.out.print(i+"*"+j+"="+i*j+"\t");
            System.out.println();
    }
}
}
不出现重复的乘积(下三角)
public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i<=9;i++)
    {   for(j=1;j<=i;j++)
            System.out.print(i+"*"+j+"="+i*j+"\t");
            System.out.println();
    }
}
}
上三角
public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i<=9;i++)
    {   for(j=i;j<=9;j++)
            System.out.print(i+"*"+j+"="+i*j+"\t");
            System.out.println();
    }
}
}
```
### 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个   第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下   的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 

1.程序分析：采取逆向思维的方法，从后往前推断。

```
public class 猴子吃桃 {
    static int total(int day){
         if(day == 10){
          return 1;
         }
         else{
          return (total(day+1)+1)*2;
         }
        }
public static void main(String[] args)
{
    System.out.println(total(1));
}
}
```
### 两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。 

1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，   则表明此数不是素数，反之是素数。

```
import java.util.ArrayList;
public class pingpang {
     String a,b,c;
     public static void main(String[] args) {
      String[] op = { "x", "y", "z" };
      ArrayList<pingpang> arrayList=new ArrayList<pingpang>();
      for (int i = 0; i < 3; i++)
       for (int j = 0; j < 3; j++)
        for (int k = 0; k < 3; k++) {
            pingpang a=new pingpang(op[i],op[j],op[k]);
         if(!a.a.equals(a.b)&&!a.b.equals(a.c)&&!a.a.equals("x")
           &&!a.c.equals("x")&&!a.c.equals("z")){
          arrayList.add(a);
         }
        }
      for(Object a:arrayList){
      System.out.println(a);
      }
     }
     public pingpang(String a, String b, String c) {
      super();
      this.a = a;
      this.b = b;
      this.c = c;
     }
     @Override
     public String toString() {
      // TODO Auto-generated method stub
      return "a的对手是"+a+","+"b的对手是"+b+","+"c的对手是"+c+"\n";
     }
}
```

### 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。 

1.程序分析：请抓住分子与分母的变化规律。

```
public class test20 {
 public static void main(String[] args) {
  float fm = 1f;
  float fz = 1f;
  float temp;
  float sum = 0f;
  for (int i=0;i<20;i++){
   temp = fm;
   fm = fz;
   fz = fz + temp;
   sum += fz/fm;
   //System.out.println(sum);
  }
  System.out.println(sum);
 }
}
```
### 求1+2!+3!+...+20!的和 

1.程序分析：此程序只是把累加变成了累乘。 

```
public class Ex21 {
    static long sum = 0;
    static long fac = 0;
    public static void main(String[] args) {
       long sum = 0;
       long fac = 1;
       for(int i=1; i<=10; i++) {
        fac = fac * i;
        sum += fac;
       }
       System.out.println(sum);
    }
    }
```
### 利用递归方法求5!。 

1.程序分析：递归公式：fn=fn_1*4! 

```
import java.util.Scanner;
public class Ex22 {
public static void main(String[] args) {
   Scanner s = new Scanner(System.in);
   int n = s.nextInt();
   Ex22 tfr = new Ex22();
   System.out.println(tfr.recursion(n));
 
}
 
public long recursion(int n) {
   long value = 0 ;
   if(n ==1 || n == 0) {
    value = 1;
   } else if(n > 1) {
    value = n * recursion(n-1);
   }
   return value;
}
 
}
```
### 有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？ 

1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。

```
public class Ex23 {
 
     static int getAge(int n){
      if (n==1){
       return 10;
      }
      return 2 + getAge(n-1);
     }
     public static void main(String[] args) {
      System.out.println("第五个的年龄为:"+getAge(5));
     }
    }
```
### 给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。

```
import java.util.Scanner;
public class Ex24 {
public static void main(String[] args) {
   Ex24 tn = new Ex24();
   Scanner s = new Scanner(System.in);
   long a = s.nextLong();
   if(a < 0 || a > 100000) {
    System.out.println("Error Input, please run this program Again");
    System.exit(0);
   }
    if(a >=0 && a <=9) {
    System.out.println( a + "是一位数");
    System.out.println("按逆序输出是" + '\n' + a);
   } else if(a >= 10 && a <= 99) {
    System.out.println(a + "是二位数");
    System.out.println("按逆序输出是" );
    tn.converse(a);
   } else if(a >= 100 && a <= 999) {
    System.out.println(a + "是三位数");
    System.out.println("按逆序输出是" );
    tn.converse(a);
   } else if(a >= 1000 && a <= 9999) {
    System.out.println(a + "是四位数");
    System.out.println("按逆序输出是" );
    tn.converse(a);
   } else if(a >= 10000 && a <= 99999) {
    System.out.println(a + "是五位数");
    System.out.println("按逆序输出是" );
    tn.converse(a);
   }
}
public void converse(long l) {
   String s = Long.toString(l);
   char[] ch = s.toCharArray();
   for(int i=ch.length-1; i>=0; i--) {
    System.out.print(ch[i]);
   }
}
}
```
### 一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。

```
import java.util.Scanner; 
public class Ex25 { 
    static int[] a = new int[5]; 
    static int[] b = new int[5]; 
    public static void main(String[] args) { 
        boolean is =false; 
        Scanner s = new Scanner(System.in); 
        long l = s.nextLong(); 
        if (l > 99999 || l < 10000) { 
            System.out.println("Input error, please input again!"); 
            l = s.nextLong(); 
        } 
        for (int i = 4; i >= 0; i--) { 
            a[i] = (int) (l / (long) Math.pow(10, i));
            l =(l % ( long) Math.pow(10, i)); 
            System.out.println(); 
        for(int i=0,j=0; i<5; i++, j++) { 
            b[j] = a[i]; 
        } 
        for(int i=0,j=4; i<5; i++, j--) { 
            if(a[i] != b[j]) { 
                is = false; break; 
            } else {
                is = true;
              } 
         } 
        if(is == false) {  
            System.out.println("is not a Palindrom!");  
        } else if(is == true) {  
        System.out.println("is a Palindrom!");  
          }  
      }  
  }
```
### 请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续   判断第二个字母。  

1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。  

```
import java.util.Scanner;
public class Ex26 {
 public static void main(String[] args){
  //保存用户输入的第二个字母
  char weekSecond;
  //将Scanner类示例化为input对象，用于接收用户输入
  Scanner input = new Scanner(System.in);
  //开始提示并接收用户控制台输入
  System.out.print("请输入星期值英文的第一个字母，我来帮您判断是星期几：");
  String letter = input.next();
  //判断用户控制台输入字符串长度是否是一个字母
  if (letter.length() == 1){
   //利用取第一个索引位的字符来实现让Scanner接收char类型输入
   char weekFirst = letter.charAt(0);
   switch (weekFirst){
  case 'm':
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case 'M':
      System.out.println("星期一(Monday)");
     break;
     case 't':
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case 'T':
      System.out.print("由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：");
     letter = input.next();
     //判断用户控制台输入字符串长度是否是一个字母
     if (letter.length() == 1){
      //利用取第一个索引位的字符来实现让Scanner接收char类型输入
      weekSecond = letter.charAt(0);
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      if (weekSecond == 'U' || weekSecond == 'u'){
       System.out.println("星期二(Tuesday)");
       break;
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      } else if (weekSecond == 'H' || weekSecond == 'h'){
       System.out.println("星期四(Thursday)");
       break;
      //控制台错误提示
      } else{
       System.out.println("输入错误，不能识别的星期值第二个字母，程序结束！");
       break;
      }
     } else {
      //控制台错误提示
      System.out.println("输入错误，只能输入一个字母，程序结束！");
      break;
     }
    case 'w':
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case 'W':
     System.out.println("星期三(Wednesday)");
     break;
    case 'f':
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case 'F':
     System.out.println("星期五(Friday)");
     break;
    case 's':
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case 'S':
     System.out.print("由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：");
     letter = input.next();
     //判断用户控制台输入字符串长度是否是一个字母
     if (letter.length() == 1){
      //利用取第一个索引位的字符来实现让Scanner接收char类型输入
      weekSecond = letter.charAt(0);
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      if (weekSecond == 'A' || weekSecond == 'a'){
       System.out.println("星期六(Saturday)");
       break;
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      } else if (weekSecond == 'U' || weekSecond == 'u'){
       System.out.println("星期日(Sunday)");
       break;
      //控制台错误提示
      } else{
       System.out.println("输入错误，不能识别的星期值第二个字母，程序结束！");
       break;
      }
     } else{
      //控制台错误提示
      System.out.println("输入错误，只能输入一个字母，程序结束！");
      break;
     }
    default:
     //控制台错误提示
     System.out.println("输入错误，不能识别的星期值第一个字母，程序结束！");
     break;
   }
  } else{
   //控制台错误提示
   System.out.println("输入错误，只能输入一个字母，程序结束！");
  }
 }
}
```
### 打印出如下图案（菱形） 

_*   

_***   

_******   

_********   

_******   

_***   

_*   

1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重   for循环，第一层控制行，第二层控制列。 

```
三角形：
public class StartG {
   public static void main(String [] args)
   {
       int i=0;
       int j=0;
       for(i=1;i<=4;i++)
       {   for(j=1;j<=2*i-1;j++)
               System.out.print("*");
            System.out.println("");   
       }
       for(i=4;i>=1;i--)
       { for(j=1;j<=2*i-3;j++)
               System.out.print("*");
                System.out.println("");   
       }
   }
 }
 
菱形：
public class StartG {
   public static void main(String [] args)
   {
       int i=0;
       int j=0;
       for(i=1;i<=4;i++)
       {
           for(int k=1; k<=4-i;k++)
             System.out.print(" ");
           for(j=1;j<=2*i-1;j++)
               System.out.print("*");
           System.out.println("");   
       }
       for(i=4;i>=1;i--)
       {
           for(int k=1; k<=5-i;k++)
                 System.out.print(" ");
           for(j=1;j<=2*i-3;j++)
               System.out.print("*");
            System.out.println("");   
       }
   }
 }
```
### 题目：打印出杨辉三角形（要求打印出10行如下图）  

1.程序分析：  

1  

1   1  

1   2   1  

1   3   3   1  

1   4   6   4   1  

1   5   10   10   5   1  

```
public class Ex33 {
    public static void main(String args[]){
           int i,j;
           int a[][];
           a=new int[8][8];
          for(i=0;i<8;i++){
             a[i][i]=1;
             a[i][0]=1;
            }
          for(i=2;i<8;i++){
           for(j=1;j<=i-1;j++){
          a[i][j]=a[i-1][j-1]+a[i-1][j];
           }
          } 
          for(i=0;i<8;i++){
          for(j=0;j<i;j++){ 
           System.out.printf("  "+a[i][j]);
           }
          System.out.println();
          }
         }
}
```
### 求100之内的素数  
```
public class Ex27 {
 public static void main(String args[])
 {
  int sum,i;
  for(sum=2;sum<=100;sum++)
  {
   for(i=2;i<=sum/2;i++)
   {
    if(sum%i==0)
     break;
   }
   if(i>sum/2)
    System.out.println(sum+"是素数");
  }
 }
}
```

### 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组
```
import java.util.*;
public class Ex35 {
public static void main(String[] args) {
int i, min, max, n, temp1, temp2;
int a[];
System.out.println("输入数组的长度:");
Scanner keyboard = new Scanner(System.in);
n = keyboard.nextInt();
a = new int[n];
for (i = 0; i < n; i++) {
System.out.print("输入第" + (i + 1) + "个数据");
a[i] = keyboard.nextInt();
}
//以上是输入整个数组
max = 0;
min = 0;
//设置两个标志,开始都指向第一个数
for (i = 1; i < n; i++) {
if (a[i] > a[max])
max = i; //遍历数组,如果大于a[max]，就把他的数组下标赋给max
if (a[i] < a[min])
min = i; //同上，如果小于a[min],就把他的数组下标赋给min
}
//以上for循环找到最大值和最小值，max是最大值的下标，min是最小值的下标
temp1 = a[0];
temp2 = a[min]; //这两个temp只是为了在交换时使用
 
a[0] = a[max];
a[max] = temp1; //首先交换a[0]和最大值a[max]
 
if (min != 0) { //如果最小值不是a[0]，执行下面
a[min] = a[n - 1];
a[n - 1] = temp2; //交换a[min]和a[n-1]
} else {       //如果最小值是a[0],执行下面
a[max] = a[n - 1];
a[n - 1] = temp1;
}
 
for (i = 0; i < n; i++) { //输出数组
System.out.print(a[i] + " ");
}
}
}
```
### 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？
```
public class Dg {
static int ts=0;//桃子总数
int fs=1;//记录分的次数
static int hs=5;//猴子数...
int tsscope=5000;//桃子数的取值范围.太大容易溢出.
public int fT(int t){
if(t==tsscope){
//当桃子数到了最大的取值范围时取消递归
System.out.println("结束");
return 0;
}
else{
if((t-1)%hs==0 && fs <=hs){
if(fs==hs)
{
System.out.println("桃子数 = "+ts +" 时满足分桃条件");
}
   fs+=1;
   return fT((t-1)/5*4);// 返回猴子拿走一份后的剩下的总数
}
else
{
//没满足条件
fs=1;//分的次数重置为1
return fT(ts+=1);//桃子数加+1
}
}
}
public static void main(String[] args) {
new Dg().fT(0);
}
 
}
```
### 输入3个数a,b,c，按大小顺序输出。  
1.程序分析：利用指针方法。
```
public class Ex34 {
    public static void main(String[] args)
    {
    int []arrays = {800,56,500};
    for(int i=arrays.length;--i>=0;)
    {
    for(int j=0;j<i;j++)
    {
    if(arrays[j]>arrays[j+1])
    {
    int temp=arrays[j];
    arrays[j]=arrays[j+1];
    arrays[j+1]=temp;
    }
    }
    }
    for(int n=0;n<arrays.length;n++)
    System.out.println(arrays[n]);
    }
 
}
```

### 有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位
```
import java.util.Scanner;
public class Ex37 {
    public static void main(String[] args) {
           Scanner s = new Scanner(System.in);
           int n = s.nextInt();
           boolean[] arr = new boolean[n];
           for(int i=0; i<arr.length; i++) {
            arr[i] = true;//下标为TRUE时说明还在圈里
           }
           int leftCount = n;
           int countNum = 0;
           int index = 0;
           while(leftCount > 1) {
            if(arr[index] == true) {//当在圈里时
             countNum ++; //报数递加
             if(countNum == 3) {//报道3时
              countNum =0;//从零开始继续报数
              arr[index] = false;//此人退出圈子
              leftCount --;//剩余人数减一
             }
            }
            index ++;//每报一次数，下标加一
            if(index == n) {//是循环数数，当下标大于n时，说明已经数了一圈，
             index = 0;//将下标设为零重新开始。
            }
           }
           for(int i=0; i<n; i++) {
            if(arr[i] == true) {
             System.out.println(i);
            }
           }
     }
}
```
### 写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度
```
import java.util.Scanner;
public class Ex38 {
public static void main(String [] args)
{
    Scanner s = new Scanner(System.in);
    System.out.println("请输入一个字符串");
    String mys= s.next();
    System.out.println(str_len(mys));
}
  public static int str_len(String x)
  {
      return x.length();
  }
}
```

### 取一个整数a从右端开始的4～7位。    
程序分析：可以这样考虑：    
(1)先使a右移4位。    
(2)设置一个低4位全为1,其余全为0的数。可用~(~0 < <4)    
(3)将上面二者进行&运算。  

```   
import java.util.Random;
public class ArraySort {
  public static void main(String[] args)
  {  int temp=0;
      int myarr[] = new int[12];
      Random r=new Random();
      for(int i=1;i<=10;i++)
        myarr[i]=r.nextInt(1000);
      for (int k=1;k<=10;k++)
      System.out.print(myarr[k]+",");
      for(int i=1;i<=9;i++)
          for(int k=i+1;k<=10;k++)
              if(myarr[i]>myarr[k])
              {
                  temp=myarr[i];
                  myarr[i]=myarr[k];
                  myarr[k]=temp;
              }
      System.out.println("");
      for (int k=1;k<=10;k++)
          System.out.print(myarr[k]+",");
   
       myarr[11]=r.nextInt(1000);
       for(int k=1;k<=10;k++)
           if(myarr[k]>myarr[11])
           {
               temp=myarr[11];
               for(int j=11;j>=k+1;j--)
                   myarr[j]=myarr[j-1];
               myarr[k]=temp;
           }
         System.out.println("");  
       for (int k=1;k<=11;k++)
              System.out.print(myarr[k]+",");
  }
}
``` 
### 对10个数进行排序  
1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，  
依次类推，即用第二个元素与后8个进行比较，并进行交换。  

```   
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;
public class Ex28 {
 public static void main(String[] args) {
  int arr[] = new int[11];
  Random r=new Random();
  for(int i=0;i<10;i++){
   arr[i]=r.nextInt(100)+1;//得到10个100以内的整数
  }
  Arrays.sort(arr);
  for(int i=0;i<arr.length;i++){
   System.out.print(arr[i]+"\t");
  }
  System.out.print("\nPlease Input a int number: ");
  Scanner sc=new Scanner(System.in);
  arr[10]=sc.nextInt();//输入一个int值
  Arrays.sort(arr);
  for(int i=0;i<arr.length;i++){
   System.out.print(arr[i]+"\t");
  }
 }
}
```  
### 有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。    
1.   程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，  
插入后此元素之后的数，依次后移一个位置。   

```   
import java.util.Random;
public class ArraySort {
  public static void main(String[] args)
  {  int temp=0;
      int myarr[] = new int[12];
      Random r=new Random();
      for(int i=1;i<=10;i++)
        myarr[i]=r.nextInt(1000);
      for (int k=1;k<=10;k++)
      System.out.print(myarr[k]+",");
      for(int i=1;i<=9;i++)
          for(int k=i+1;k<=10;k++)
              if(myarr[i]>myarr[k])
              {
                  temp=myarr[i];
                  myarr[i]=myarr[k];
                  myarr[k]=temp;
              }
      System.out.println("");
      for (int k=1;k<=10;k++)
          System.out.print(myarr[k]+",");
   
       myarr[11]=r.nextInt(1000);
       for(int k=1;k<=10;k++)
           if(myarr[k]>myarr[11])
           {
               temp=myarr[11];
               for(int j=11;j>=k+1;j--)
                   myarr[j]=myarr[j-1];
               myarr[k]=temp;
           }
         System.out.println("");  
       for (int k=1;k<=11;k++)
              System.out.print(myarr[k]+",");
  }
}
```  
### **列出目录下的所有的目录和文件**
``` 
import java.io.File;
public class Test {
    public static void main(String[] args) {
        File file = new File("C:\\testDir");
        //判断目录是否存在
        if(!file.exists()) {
            System.out.println("dirctory is empty");
            return;
        }
        File[] fileList = file.listFiles();
        for(int i = 0;i<fileList.length;i++) {
            if(fileList[i].isDirectory()) {
                System.out.println("dirctory is:"+fileList[i].getName());
            }else {
                System.out.println("file is:"+fileList[i].getName());
            }
        }
    }
}
```
### **获得回文字符串**
### 去除字符串的n个字符得到回文字符串 返回n

``` 
/*
 * 用动态规划 先反转字符串，从（1，1）开始赋值同位比较相等则=左上角+1 不等则=左侧和上方中的较大值
 * */
import java.util.*;
public class demo0920 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String s1 = sc.next();
            String s2 = new StringBuilder(s1).reverse().toString();
            int[][] dp = new int[s1.length() + 1][s2.length() + 1];
            for (int i = 1; i < dp.length; i ++ ) {
                for (int j = 1; j < dp[0].length; j ++ ) {
                    dp[i][j] = s1.charAt(i - 1) == s2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
            System.out.println(s1.length() - dp[s1.length()][s2.length()]);
        }
    }
}
```
![](https://viabcde.github.io/images/2018-09-20/2018092001.png)  

### **将字符串中的大写字符放到最后**
``` 
import java.util.*;
public class demo092001{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext()){
            String str = scan.nextLine();
            System.out.println(getResult(str));
        }
    }
    public static String getResult(String str){
        //Aaaa 把大写的去除 变成 aaa 把小写的去除变成A 两者拼接aaaA
    	return str.replaceAll("[A-Z]","")+str.replaceAll("[a-z]","");
    }
      
}
```
### **奇偶倒推**
有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。
魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币
魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币
采购魔法神器总共需要n个魔法币,所以只能通过两台魔法机器产生恰好n个魔法币,
设计一个投入方案最后恰好拥有n个魔法币。

2台机器1台只能产生奇数，1台只能产生偶数
可以通过判断结果是奇数还是偶数倒推上一次的结果，再倒推至0即可退出
使用StringBuiler一来大量字符串拼接效率更高，另一方面倒推的操作输出需要反向，sb有reverse可以直接调用
``` 
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            int coinCount = in.nextInt();
            StringBuilder sb = new StringBuilder();
            while (coinCount > 0) {
                if (coinCount % 2 == 0) {
                    //偶数
                    coinCount = (coinCount - 2) / 2;
                    sb.append("2");
                } else {
                    //奇数
                    coinCount = (coinCount - 1) / 2;
                    sb.append("1");
                }
            }
            System.out.println(sb.reverse().toString());
        }
    }
}
```
### **三角**
``` 
public class demo0919 {
	public static void main(String[] args) {
		for(int y=0;y<4;y++){
			for(int x=0;x<4;x++){
				if(x>y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
		for(int y=0;y<4;y++){
			for(int x=0;x<4;x++){
				if(x<3-y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
		for(int y=0;y<4;y++){
			for(int x=0;x<4;x++){
				if(x<y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
		for(int y=0;y<4;y++){
			for(int x=0;x<4;x++){
				if(x>3-y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
		for(int y=0;y<4;y++){
			for(int x=0;x<7;x++){
				if(x<3-y||x>3+y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
		for(int y=0;y<4;y++){
			for(int x=0;x<7;x++){
				if(x<y||x>6-y){
					System.out.print(" ");
				}else{
					System.out.print("1");
				}
				
			}
			System.out.println();
		}
		System.out.println("---------------------------------");
	}
}


```
![enter description here](https://viabcde.github.io/images/2018-09-21/三角形.png)
第一象限 x>y 
第二象限 x<3-y 内层-1
第三象限 x<y 
第四象限 x>3-y 内层-1
左右(上) x<3-y||x>3+y 内层-1  
左右(下) x<y||x>6-y 外层-1

### **StringBuiler的字符串反转**
为了得到一个数的"相反数",我们将这个数的数字顺序颠倒,然后再加上原先的数得到"相反数"。例如,为了得到1325的"相反数",首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.

``` 
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        System.out.println(Integer.parseInt(new StringBuilder(s).reverse().toString())+Integer.parseInt(s));
        sc.close();
    }
}
```
### **字符串碎片的平均长度**
一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,"aaabbaaac"是由下面碎片组成的:'aaa','bb','c'。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。

``` 
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    while (sc.hasNext()) {
        String s = sc.next();
        float len = s.length();//总长
        int count = 1;//个数至少为一个
        for (int i = 0; i < len - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) {
                count++;
            }
        }
        System.out.println(len / count);
    }
}
```
### 兔子的规律为数列1,1,2,3,5,8,13,21....

```
        if(x==1 || x==2)
            return 1;
        else
            return f(x-1)+f(x-2);
```

### 水仙花数

```
       int i=0,j=0,k=0;
       i=x / 100;
       j=(x % 100) /10;
       k=x % 10;
       if(x==i*i*i+j*j*j+k*k*k)
          return true;
       else
          return false;
```

### 学习成绩> =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示
str=(N>90?"A":(N>60?"B":"C"));
### 辗转相除法

```
    static int commonDivisor(int M, int N)
    {
        if(N<0||M<0)
        {
            System.out.println("ERROR!");
            return -1;
        }
        if(N==0)
        {
            return M;
        }
        return commonDivisor(N,M%N);
    }
```

辗转相除法原理：用较大的除以较小的 用较小的去除以余数
 
![enter description here](https://viabcde.github.io/images/2018-09-27/2018092701.png)
```
public static int gcd(int m, int n) {
while (true) {
if ((m = m % n) == 0)
return n;
if ((n = n % m) == 0)
return m;
}
}
```

最小公倍数=( m*n)/最大公约数
### 求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制

```
      int s=0;
      String output="";
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      System.out.println("请输入a的值");
      String input =stadin.readLine();
      for(int i =1;i<=Integer.parseInt(input);i++)
      {
          output+=input;
          int a=Integer.parseInt(output);
          s+=a;
      }
```

### 有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？

```
public static void main(String[] args) {
    int i=0;
    int j=0;
    int k=0;
    int t=0;
    for(i=1;i<=4;i++)
        for(j=1;j<=4;j++)
            for(k=1;k<=4;k++)
                if(i!=j && j!=k && i!=k)
                {t+=1;
                    System.out.println(i*100+j*10+k);
 } 
    System.out.println (t);
    }
```

### 输入某年某月某日，判断这一天是这一年的第几天？
if(year%400==0||(year%4==0&&year%100!=0))/*判断是不是闰年*/
### 九九乘法

```
int i=0;
    int j=0;
    for(i=1;i<=9;i++)
    {   for(j=1;j<=i;j++)
            System.out.print(j+"*"+i+"="+i*j+"\t");
            System.out.println();
    }
```

### 用递归实现阶乘

```
public static long fac(int n){
        if(n<=0) return 0;
        else if(n==1)    return 1;
        else return n*fac(n-1);
    }
    public static void main(String [] args) {
        System.out.println(fac(6));
    }
```

### 编写一个程序，有1，2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？

```
public class T {
	public static void main(String [] args) {
	       int i, j, k;
	       int m=0;
	       for(i=1;i<=4;i++)
	          for(j=1;j<=4;j++)
	            for(k=1;k<=4;k++){
	               if(i!=j&&k!=j&&i!=k){
	            	 //双引号的作用是把打印的内容当做字符串输出 后面加的数字都自动转为字符串  
	                 System.out.println(""+i+j+k);
	                 m++;
	               }
	            }
	        System.out.println("能组成："+m+"个");
	}
}
```

### 639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172*639172=408540845584），类似于639172这样的6位数还有几个？分别是什么？

```
public void selectNum(){  
        for(long n = 100000; n <= 999999;n++){   
            if(isSelfRepeat(n))                    //有相同的数字，则跳过
                continue;   
            else if(isPingFangRepeat(n*n,n)){    //该数的平方中是否有与该数相同的数字
                continue;   
            }
            else{                                //符合条件，则打印
                   System.out.println(n); 
            }   
        } 
     }

    public boolean isSelfRepeat(long n){
        HashMap<Long,String> m=new HashMap<Long,String>();
        //存储的时候判断有无重复值 每次取最后一位数判断是否已重复 没有则放入hashmap
//再利用/去掉最后一位数 再重新对新的最后一位数进行判断
        while(n!=0){
            if(m.containsKey(n%10)){
                return true;
            }
            else{
                m.put(n%10,"1");
            }
            n=n/10;
        }
        return false;
    }

    public boolean isPingFangRepeat(long pingfang,long n){
        HashMap<Long,String> m=new HashMap<Long,String>();
        while(n!=0){
            m.put(n%10,"1");
            n=n/10;
        }

        while(pingfang!=0){
            if(m.containsKey(pingfang%10)){
                return true;
            }
            pingfang=pingfang/10;
        }
        return false;
    }

    public static void main(String args[]){
        new test().selectNum();
    }
```

![enter description here](https://viabcde.github.io/images/2018-09-27/2018092702.png)

```
public class testClockwiseOutput { 
    //顺时针打印一个矩阵 
    
    @Test 
public void test(){ 
//初始化矩阵
        int[][] num = new int[100][100]; 
        int n = 4; 
        int count =1; 
        
        for(int i=0;i<n;i++){ 
            for(int j =0;j<n;j++){ 
                num[i][j]=count++; 
            } 
        } 
        
        output(num,0,n-1); 
    } 
    //使用递归每次递归输出一圈
    public void output(int[][] num,int start,int end){ 
        if(start>=end || end<=0)return; 
        //输出上面的一行
        for(int i=start;i<=end;i++){ 
            System.out.println(num[start][i]); 
        } 
        //输出右侧一列
        for(int i=start+1;i<=end;i++){ 
            System.out.println(num[i][end]); 
        } 
         //输出下面一行
 for(int i=end-1;i>=start;i--){ 
            System.out.println(num[end][i]); 
        } 
        //输出左侧一列
for(int i=end-1;i>start;i--){ 
            System.out.println(num[i][start]); 
        } 
        //递归重复操作
        output(num,start+1,end-1); 
    } 
}
```

### 给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数 并输出该子数组

```
@Test 
public void test(){ 
//初始化
        int[] num = {1,2,2,3,4,5,6,7,8,9}; 
        int sum = 7; 
        findSum(num,sum); 
    } 
    
    public void findSum(int[] num,int sum){ 
        int left=0; 
        int right=0; 
        for(int i=0;i<num.length;i++){ 
            int curSum = 0; 
            left = i; 
            right = i; 
            //把当前数组从左开始累加至大于给定的数即停止
while(curSum<sum){ 
                curSum += num[right++]; 
            }
            //停止后判断是否与给定数相等 不等则继续循环从左侧第2个数开始累加
            if(curSum==sum){ 
                for(int j=left;j<right;j++){ 
                    System.out.print(num[j]+" "); 
                } 
                System.out.println(); 
            } 
        } 
    }
```

### 用二分法查找已排序好的字母中的随机一个字母的下标

```
public class Test5{
    public static int binarySearch(char[] b,char c){
        int min=0,max=b.length-1,mid=0;
        while(min<=max){
         mid=(max+min)/2;
            if(c<b[mid])
                max=mid-1;
            else if(c>b[mid]){
                min=mid+1;
            System.out.println("hello");}
            else
                break;
                                    }
        return mid;
    }
    public static void main(String[] args) {
        char[] a={'a','b','c','d','e','f','g','h'};
        System.out.println("g在数组中的下标是"+binarySearch(a,'g'));
    }
}
```

  
### 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个， 如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。
分析：字符串打散成字节之后输出的字节值变成了正数和负数，字符为一个正数，汉字为两个负数
所以为了不输出半个汉字，可以判断负数的个数，然后确定截取数到底是多少，通过new String(buf,0,len)的构造方法把字节转换成字符串

```
import java.util.Scanner;

public class T {
    public static void main(String[] args) {
        Scanner scan=new Scanner(System.in);
        while(true) {
            System.out.println("请输入一个带中文的字符串，和要截取的字节数：");
            String str=scan.next();
            int num=scan.nextInt();
            
            byte[] buf=str.getBytes();
            if(num<=buf.length) {
                System.out.println("输入正确，即将截取字符串...");
                int times=0;
                for(int i=0;i<num;i++) {
                    System.out.println(buf[i]);
                	if(buf[i]<0) {
                        times++;
                    }
                }
                if(times%2==1) {
                    num--;
                }
                String out=new String(buf,0,num);//字节转成字符串
                System.out.println("截取的字符串是："+out);
                System.out.println();
            }else {
                try {
                    throw new MyException("截取字节数超出字符串长度．．．");
                } catch (MyException e) {
                    e.printStackTrace();
                }
            }
        }
        
    }
}

class MyException extends Exception{
    public MyException(String msg) {
        super(msg);
    }
}


```
### 数组中相加等于20的组合 的集合

```
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/*
*先从小到大排序 首尾相加若小于20则把小的去除（即begin指针往前(右边)移）
*首尾相加若大于20则把小的去除（即end指针往前（左边）移）
*/
public class Test_plus {
    public static void findSum(int[] a,int sum) {
        Arrays.sort(a);
        int begin=0;
        int end=a.length-1;
        while(begin<end) {
            if(a[begin]+a[end]<sum)
                begin++;
            else if(a[begin]+a[end]>sum)
                end--;
            else {
                System.out.println(a[begin]+","+a[end]);
                begin++;
                end--;
            }
        }
    }
    public static void main(String[] args) {
        int array[]= {1,7,17,2,6,3,14};
        findSum(array, 20);
    }

}
```
### 取出数组中重复最多的数

```
思路：把数组中的每个元素作为key存到map中 如果map没有value 设为1 
有则value+1
然后用类似于选择排序的算法取出value 最大的那个value 的key即可

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/*
*利用map key唯一性 唯一来存储数组的原数，而每遍历map中判断出已有key（即已有相同元素）存在，则key对应的value+1
*若没有，则把元素设为key，value设为1
*/
public class Test_plus {
    public static int findMostFrequentInArray(int[] a) {
        int result = 0;
        int size = a.length;
        if(size==0)
            return Integer.MAX_VALUE;
        Map<Integer,Integer>m=new HashMap<Integer,Integer>();
        //开始遍历数组，往map中设置数组中每个元素(对应map中的key)对应出现的次数(对应map中的value)
        for(int i=0;i<size;i++) {
            if(m.containsKey(a[i])) {
                m.put(a[i], m.get(a[i])+1);
            }
            else {
                m.put(a[i], 1);
            }
        }
        int most=0;
        Iterator iter = m.entrySet().iterator();
        //开始遍历 比较map中每个key对应的value，取最大值，返回
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            int key=(Integer)entry.getKey();
            int val=(Integer)entry.getValue();
            if(val>most) {
                result=key;
                most=val;
            }
        }
        return result;
    }
    public static void main(String[] args) {
        int[] array= {1,5,4,3,4,4,5,4,5,5,6,6,6,6,6};
        int maxFrequenceNum=findMostFrequentInArray(array);
        System.out.println(maxFrequenceNum);
    }

}
```
### 将数组移k位右

```
思路 ： 反转的算法 *3次即可
先把 第 k-n-1 反转
把0 -k-1 反转
整体反转 即可

//把数组循环右移K位
public class Test_plus {
    /*
    *数组倒序算法，循环首尾互换
    */
    public static void reverse(int[] a,int b,int e) {
        for(;b<e;b++,e--) {
            int temp=a[e];
            a[e]=a[b];
            a[b]=temp;
        }
    }
    public static void shift_k(int[] a,int k) {
        int n=a.length;
        //右移k位和右移n+k位等价
        k=k%n;
        //将倒数第k个和最后一个之间的数组段对换循环
        reverse(a,n-k,n-1);
        //将第一个和第倒数第k-1个数对换
        reverse(a,0,n-k-1);
        //将第一个数和最后一个数之间的数对换
        reverse(a,0,n-1);
    }
    public static void main(String[] args) {
        int array[]= {1,2,3,4,5,6,7,8};
        shift_k(array, 2);
        for(int i=0;i<array.length;i++) {
            System.out.println(array[i]+"");
        }
    }

}
```
### 判断两个字符串是否有相同字符（每个字母的个数也相同）组成

```
初始化一个字符串数组 每个位赋值为0 即 0000 0000 0000 0000...
对第一个字符串 s1 转成的每个字节 如425154 在对应位置上加1 
如4则在 第四的位置加1 0001 0000 0000 0000 ...
对第二个字符串 s2 转成的每个字节 如425154 在对应位置上则减1
最后只要 这个数组有一个元素不等于0 则说明 2个字符串不相等

import java.util.Arrays;

//空间换时间
public class Test_plus {
    public static void compare(String s1,String s2) {
        byte[]b1=s1.getBytes();
        byte[]b2=s2.getBytes();
        int[]bCount=new int[256];
        for(int i=0;i<256;i++) {
            bCount[i]=0;
        }
        for(int i=0;i<b1.length;i++)
            bCount[b1[i]-'0']++;
        for(int i=0;i<b2.length;i++)
            bCount[b2[i]-'0']--;
        for(int i=0;i<256;i++)
            if(bCount[i]!=0) {
                System.out.println("not equal");
                return;
            }
        System.out.println("equal");
    }
    public static void main(String[] args) {
        String s1="aaabbc";
        String s2="abcbaaa";
        compare(s1, s2);
        s1="aaaabbc";
        s2="abcbaab";
        compare(s1, s2);
    }

}
```
### 找出数组中只出现1次的数

```
任何数字异或自己都等于0，两次重复的数字异或之后抵消，最后剩下只有1个的数字
知识点：任何数字异或0等于自身
按位与 a&b 只有双方为1 才为1 
按位或 | 其中一方有1 才为1
按位异或 ^ 双方相同 为0 不同为 1
注意：本方法只适合于其他数字都出现偶次数才能用

public class Test_plus {
    public static int findNotDouble(int[] a) {
        int n=a.length;
        int result=a[0];
        int i;
        for(i=1;i<n;++i)
            result ^= a[i];
        return result;
    }
    public static void main(String[] args) {
        int array[]= {1,2,3,2,4,3,5,4,1};
        int num = findNotDouble(array);
        System.out.println(num);
    }

}
```
### 单词反转

```
思路：
实现字符串首尾反转 即对how are you 全反转 uoy era woh
再对每一个单词进行单独反转 （每读取到 ' ' 即对前面的字符串进行反转一次）
因为最后一个单词的后面没有 ' ' 所以需要单独反转


//数组中只有一个数组出现过1次，其他的都出现了3次
public class s {
    //把数组首尾元素交换
    public void swap(char[] cArr,int front,int end) {
        while(front<end) {
            char tmp=cArr[end];
            cArr[end]=cArr[front];
            cArr[front]=tmp;
            front++;
            end--;
        }
    }
    public String swapWords(String s) {
        //对how are you 全反转 uoy era woh
        char[] cArr=s.toCharArray();
        swap(cArr,0,cArr.length-1);
        //对 当个单词进行反转 uoy - you; era - are ; woh -how(找不到 ' '  无法反转)
        int begin=0;
        for(int i=1;i<cArr.length;i++) {
        if(cArr[i]==' ') {
            swap(cArr,begin,i-1);
            begin=i+1;
        }
    }
        //所以要把最后一个单词单独反转 woh -how
    swap(cArr,begin,cArr.length-1);
    return new String(cArr);
    }
    public static void main(String[] args) {
        String str="how are you";
            System.out.println(new s().swapWords(str));
    }

}
```
### 数组中2个元素的最小距离

```
# 思路 ： 当同时找到2个元素时才开始比较两者之间的距离 使用最新的下标进行比较

import java.util.concurrent.atomic.AtomicInteger;

//数组中只有一个数组出现过1次，其他的都出现了3次
public class s {
    private static int min(int a,int b) {
        return a>b?b:a;
    }
    public static int minDistance(int[] a,int n1,int n2) {
        if(a==null)
            return Integer.MIN_VALUE;
        int len=a.length;
        int n1_index=-1;
        int n2_index=-1;
        int min_dist=Integer.MIN_VALUE+1;
        System.out.println(min_dist);
        System.out.println(Math.abs(min_dist));
        for(int i=0;i<len;++i) {
            //当首次第一个元素与第二个元素同时存在时才执行下面语句
            if(a[i]==n1) {
                n1_index=i;
                if(n2_index>=0)
                    min_dist=min(Math.abs(min_dist),Math.abs(n1_index-n2_index));
                System.out.println(min_dist);
            }
            if(a[i]==n2) {
                n2_index=i;
                if(n1_index>=0)
                    min_dist=min(Math.abs(min_dist),Math.abs(n2_index-n1_index));
                System.out.println(min_dist);
            }
        }
        return min_dist;
    }
    public static void main(String[] args) {
        int[] a= {0,1,2,3,4,5,6,7,8};
        System.out.println(minDistance(a, 0, 7));

    }

}
```
### 求数组第二大的数（选择排序）

```
定义一个最大 和第二大的数 
每次循环都判断数组中是否有比最大的数大的有则交换两者的值
同时 把原来最大数的值赋值给第二大的


public class SecondMax {
    public static int FindSecMax(int[] data) {
        int count = data.length;
        int maxnumber = data[0];
        int sec_max = Integer.MIN_VALUE;
        for(int i = 1;i<count;i++) {
            if(data[i]>maxnumber) {
                sec_max = maxnumber;
                maxnumber=data[i];
            }
            else {
                if(data[i]>sec_max)
                    sec_max = data[i];
            }
        }
        return sec_max;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array = {7,3,19,40,4,7,1};
        System.out.println(FindSecMax(array));
    }

}
```
### 反射机制示例

```
/*获取class类*/
*class.forName("类的路径")
*类名.class
*实例名.getClass()
*/
class Base {
     public void f() {
         System.out.println("Base");
     }
}
class Sub extends Base{
     public void f() {
         System.out.println("Sub");
     }
}

public class Test_Base {

    public static void main(String[] args) {
        try {
            Class c = Class.forName("Sub");
            Base b = (Base)c.newInstance();
            b.f();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
```
### HashMap可插入相同key的错觉(hashcode不同 equals 相等)

```
test1()是正常情况：当插入 相同key 时 后者会把前者覆盖
test2()是因为插入的key p1 和 p2是2个实例对象 虽然他们在内存中的首地址不同，但他们的实际内容是相同的
所以p1和p2 的 Person类必须实现 hashcode 和equals方法 以防止 插入相同内容的key


import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class TestPerson {
    public static void test1() {
        System.out.println("User user defined class as key");
        HashMap<String,String>hm = new HashMap<String,String>();
        hm.put("aaa","bbb");
        hm.put("aaa","ccc");
        Iterator iter = hm.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            String key = (String)entry.getKey();
            String val = (String)entry.getValue();
            System.out.println(key+"     "+val);
        }
    }
    public static void test2(){
        System.out.println("Use String as Key:");
        HashMap<Person,String>hm = new HashMap<Person,String>();
        Person p1 = new Person("111", "name1");
        Person p2 = new Person("111", "name1");
        hm.put(p1,"address1");
        hm.put(p2,"address2");
        Iterator iter = hm.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            Person key = (Person)entry.getKey();
            String val = (String)entry.getValue();
            System.out.println(key+"     "+val);
        }

    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        test1();
        System.out.println(" ");
        test2();
    }

}
实现 hashcode和equals


import java.util.*;
 class Person {
     String id;
     String name;
     public int hashCode() {
         return id.hashCode();
     }
     public Person(String id,String name) {
         this.id = id;
         this.name = name;
     }
     public String toString() {
         return "id ="+id+",name = "+name;
     }
     public boolean equals(Object obj) {
            Person p = (Person) obj;
            if(p.id.equals(this.id))
                return true;
            else
                return false;
        }
}
```
### **斐波那契函数**
``` 
public class Demo2 {
	// 定义三个变量方法
	public static void main(String[] args) {
		int a = 1, b = 1, c = 0;
		System.out.println("斐波那契数列前20项为：");
		System.out.print(a + "\t" + b + "\t");
		//因为前面还有两个1、1 所以i<=18
		for (int i = 1; i <= 18; i++) {
			c = a + b;
			a = b;
			b = c;
			System.out.print(c + "\t");
			if ((i + 2) % 5 == 0)
				System.out.println();
		}
	}
 
}

```



