--- 
layout: post
title: Mybatis缓存
date: 2018-11-19
tags: Mybatis
---
**一级缓存:** session是一个HashMap,存放对象的引用    
**二级缓存:** 跨多个session 
在 session commit 时 清空一级缓存 (防止其他用户 读取到 修改的脏数据)  
首先判断二级缓存有没有 再判断一级缓存有没有 都没有后 才执行sql语句  
session 共享一个Usermapper二级缓存 但不共享 goodsmapper二级缓存  
如果2个mapper.xml使用相同的namespace那么就共享同一个二级缓存
开启全部二级缓存 在sqlmapconfig.xml中
![enter description
here](https://viabcde.github.io/images/blog/20180928137.png)  
仅开启一个mapper的二级缓存 usermapper,xml中
![enter description
here](https://viabcde.github.io/images/blog/20180928138.png)  
整合echache 
加入2个jar包
![enter description
here](https://viabcde.github.io/images/blog/20180928138_1.png)  
usermapper.xml中加入
![enter description
here](https://viabcde.github.io/images/blog/20180928139.png)  
echache配置文件classpath下
![enter description
here](https://viabcde.github.io/images/blog/20180928140.png)  


po实体类 实现序列化接口   
因为二级缓存 可能存在硬盘中  当从硬盘中读取需要反序列化读取  
只要sqlsession不提交 就不会清空二级缓存
请求频繁、对实时数据要求不高的数据 不要求每次都是最新数据 可以用二级缓存 （设置刷新频率久一点 30分钟 24小时）
实时性高的 操作后会自动更新缓存 即把缓存清空了
二级缓存 局限性：
A客户查询 了 a 商品 B客户查询了 b商品 …都存入了二级缓存 （有1w个商品）
当有一个更新商品的操作 那么二级缓存全部被清空了 因此可以说mybatis二级缓存只能针对整个mapper 而不是某一种操作设置二级缓存，粒度不够细
**缓存**  
同hibernate一样，一级缓存（session级）是默认开启的，如果需要开启二级缓存，就需要加以下配置：

``` 
<!-- 在核心配置文件中加入配置 -->
<setting name="cacheEnabled" value="true"/>

<!-- 在mapper文件中加入配置 -->
<cache />
```
<cache /> 语句的效果如下：
映射语句文件中的所有 select 语句将会被缓存。
映射语句文件中的所有 insert， update 和 delete 语句会刷新缓存。
缓存会使用 Least Recently Used（ LRU，最近最少使用的）算法来收回。
根据时间表（比如 no Flush Interval，没有刷新间隔），缓存不会以任何时间顺序来刷新。
缓存会存储列表集合或对象（无论查询方法返回什么）的 1024 个引用。
缓存会被视为是 read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。
所有的这些属性都可以通过缓存元素的属性来修改。比如：

``` 
<cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true"/>
```
这个配置创建了一个 FIFO 缓存，并每隔 60 秒刷新， 存数结果对象或列表的512 个引用，而且返回的对象是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。
可用的收回策略有：
LRU – 最近最少使用的：移除最长时间不被使用的对象。
FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
默认的是 LRU。
**flushInterval**（刷新间隔）可以被设置为任意的正整数，它们代表一个合理的毫秒形式的时间段。默认不设置，即没有刷新间隔，缓存仅仅调用语句时刷新。
**size**（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是 1024。
**readOnly**（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例,可读写的缓存会返回缓存对象的拷贝（通过序列化）,默认是 false。
6. 动态sql：  
**if 和 choose when otherwise**  
``` 
<select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”>
  SELECT * FROM BLOG WHERE state = „ACTIVE‟
  <choose>
    <when test=”title != null”>
      AND title like #{title}
    </when>
    <when test=”author != null and author.name != null”>
      AND title like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
```
2）关键字  
**where 和 set**  

``` 


<!-- 取代where关键字，当所有if条件不成立时就不会出现where关键字 -->
<select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”>
  SELECT * FROM BLOG
  <where>
    <if test=”state != null”>
      state = #{state}
    </if>
    <if test=”title != null”>
      AND title like #{title}
    </if>
    <if test=”author != null and author.name != null”>
      AND title like #{author.name}
    </if>
  </where>
</select>


<update id="updateAuthorIfNecessary" parameterType="domain.blog.Author">
  update Author
  <set>
    <if test="username != null">username=#{username},</if>
    <if test="password != null">password=#{password},</if>
    <if test="email != null">email=#{email},</if>
    <if test="bio != null">bio=#{bio}</if>
  </set>
  where id=#{id}
</update>
```
**foreach**

``` 
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT * FROM POST P WHERE ID in
  <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
    #{item}
  </foreach>
</select>
```
