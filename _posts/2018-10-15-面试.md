--- 
layout: post
title: 面试题
date: 2018-10-24
tags: 面试
---
## **前言：因为每次面试都会有问到基础，虽然都能回答得出来，感觉还是要总结一下，不能再同一个坑掉2次**
### **Set，List 和 Map 的区别**
java集合的主要分为三种类型：  
Set（集）  
List（列表）    
Map（映射）  
要深入理解集合首先要了解下我们熟悉的数组：  
**区别1：**数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型），而JAVA集合只能存放引用类型的的数据，不能存放基本数据类型。  
世间上本来没有集合,(只有数组参考C语言)但有人想要,所以有了集合   
有人想有可以自动扩展的数组,所以有了List   
有的人想有没有重复的数组,所以有了set   
有人想有自动排序的组数,所以有了TreeSet,TreeList,Tree**   
而几乎有有的集合都是基于数组来实现的.   
因为集合是对数组做的封装,所以,数组永远比任何一个集合要快   
但任何一个集合,比数组提供的功能要多   
																				——————《Thinking In Algorithm》   
一：数组声明了它容纳的元素的类型，而集合不声明。这是由于集合以object形式来存储它们的元素。   
二：一个数组实例具有固定的大小，不能伸缩。集合则可根据需要动态改变大小。   
三：数组是一种可读/可写数据结构－－－没有办法创建一个只读数组。然而可以使用集合提供的ReadOnly方法，以只读方式来使用集合。该方法将返回一个集合的只读版本。  
1、效率高，但容量固定且无法动态改变。array还有一个缺点是，无法判断其中实际存有多少元素，length只是告诉我们array的容量。  
2、Java中有一个Arrays类，专门用来操作array。
arrays中拥有一组static函数，  
equals()：比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等。  
fill()：将值填入array中。  
sort()：用来对array进行排序。  
binarySearch()：在排好序的array中寻找元素。  
System.arraycopy()：array的复制。  
### **Collection与Collections的区别**  
Collection是集合类的上级接口，继承与他有关的接口主要有List和Set  
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作  
例子：  
``` 
public static void main(String args[]) {   
       //注意List是实现Collection接口的   
       List list = new ArrayList();   
       double array[] = { 112, 111, 23, 456, 231 };   
       for (int i = 0; i < array.length; i++) {   
           list.add(new Double(array[i]));   
       }   
       Collections.sort(list);   //把list按从小到大排序
       for (int i = 0; i < array.length; i++) {   
           System.out.println(list.get(i));   
       }   
       // 结果：23.0 111.0 112.0 231.0 456.0   
 }   
```
然后还有混排（Shuffling）、反转（Reverse）、替换所有的元素（fill）、拷贝（copy）、返回Collections中最小元素（min）、返回Collections中最大元素（max）、返回指定源列表中最后一次出现指定目标列表的起始位置（lastIndexOfSubList）、返回指定源列表中第一次出现指定目标列表的起始位置（IndexOfSubList）、根据指定的距离循环移动指定列表中的元素（Rotate）  
### **Java中HashMap的key值要是为类对象则该类需要满足什么条件？**  
需要同时重写该类的hashCode()方法和它的equals()方法。  
### **如何选择合适的Java集合框架**
根据需要确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map~  
确定完我们的集合类型，我们接下来确定使用该集合类型下的哪个子类~我认为可以简单分成几个步骤：  
是否需要同步  
去找线程安全的集合类使用  
迭代时是否需要有序(插入顺序有序)  
去找Linked双向列表结构的  
是否需要排序(自然顺序或者手动排序)  
去找Tree红黑树类型的(JDK1.8)  
估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗~  
使用泛型，避免在运行时出现ClassCastException  
尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性  
## **Servlet 的请求流程？**
### **1.浏览器发出请求** http://localhost:80/xxx1/xxx2   
**注：**（80端口可以默认不写，因为这是http协议默认的端口，平时我们访问https://www.baidu.com/ 时其实访问的是https://www.baidu.com:80/）
### **2.服务器解析请求信息**   
•http:协议名称  
•localhost:访问的是互联网中的哪一台计算机  
•80:从主机当中找到对应 80 端口的程序 （这里即为 Tomcat 服务器）  
•/xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性） 
•/xxx2:当前请求的资源名  
### **3.解析 Tomcat 服务器根目录下的 /config/server.xml 文件**  
``` 
<Context docBase="D:\javaPros\test\webapp" path="xxx1" />
```
判断哪一个<Context />元素的 path属性 属性为 xxx1  
•若找不到，则返回 404错误  
•若找到了，则解析该<Context />元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\javaPros\test\webapp  
### **4.从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件**  
 判断 web.xml 文件中是否有 <url-pattern> 的文本内容为 /xxx2    
 •若找不到，则返回 404错误    
•若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx    
### **5.判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象**  
Map<String,Servlet> cache = ......(Tomcat提供的);    
    key:存Servlet类的全限定名称    
    value:该Servlet类的对象.    
``` 
Servlet obj = cache.get("xxx.xxx");
    if(obj==null){
        //Servlet实例缓存中没有该类的对象,第一次.
        GOTO 6:
    }else{
        //有对象,非第一次.
        GOTO 8:
    }
}

```
## **servlet的生命周期**
### **1.使用反射调用构造器，创建对应的对象**
obj = Class.forName("xxx.xxx").newInstance();  
把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用.  
cache.put("xxx.xxx",obj);  
### **2.创建 ServletConfig 对象，并调用 init() 方法**
obj.init(config);  
### **3.创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法**
obj.service(req,resp);
### **4.在 service() 方法中对浏览器作出响应操作。**
## **Servlet 是单例的吗？为什么？**
Servlet 是单例的，浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。
## **Tomcat 中如何解决中文乱码问题？**
### **1.对于 POST 请求：**  
 设置请求的编码方式：request.setCharacterEncoding("UTF-8");  
注意：必须在获取第一个参数之前设置，并且该方式只对 POST 方式有效。
### **2.对于 GET 请求：**  
 重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:  
Tomcat根目录/conf/server.xml(修改端口的那一行)
![duotai](https://viabcde.github.io/images/2018-10-10/2018101007.png) 
##  **BeanFactory 和 ApplicationContext 的区别**
### **1.BeanFactory**
是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使ApplicationContext（应用上下文），原因如下。
### **2.ApplicationContext**
⑴. 继承了 BeanFactory，拥有了基本的 IoC 功能；    
⑵. 除此之外，ApplicationContext 还提供了以下功能：    
① 支持国际化；② 支持消息机制；③ 支持统一的资源加载；④ 支持AOP功能；    
**•注意：** ApplicationContext 和 BeanFactory 相比，最主要的区别在于 BeanFactory 是延迟加载，举个例子：如果 Bean 没有完全注入，BeanFactory 加载后，会在你第一次调用 getBean 方法才会抛出异常；而 ApplicationContext 会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入；所以通常我们会选择 ApplicationContext。
### **构造方法注入和设值注入有什么区别？**
请注意以下明显的区别：
在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。
设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。
在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。
在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。
### **请举例解释@Autowired注解？**
@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。
比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 <property>元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。
当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用<constructor-arg> 元素。

### **请举例解释@Required注解？**
在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在<bean>中设置“dependency-check”来解决这个问题。
在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。

### **请解释自动装配模式的区别？**
在Spring框架中共有5种自动装配，让我们逐一分析。
no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。
byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。
byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。
constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。
autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。

### **Spring Bean的作用域之间有什么区别？**
Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：
singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。
prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。
request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。
global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。
全局作用域与Servlet中的session作用域效果相同。

### **请解释Spring Bean的生命周期？**
Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。
Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。
初始化之后调用的回调方法。
销毁之前调用的回调方法。
Spring框架提供了以下四种方式来管理bean的生命周期事件：
InitializingBean和DisposableBean回调接口
针对特殊行为的其他Aware接口
Bean配置文件中的Custom init()方法和destroy()方法
@PostConstruct和@PreDestroy注解方式

## **这里搜集各种面试题**
### **什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？**
虚拟机可以将java字节码解析成机器可识别的0101二进制文件  
java由编译器一次编译成clas文件能在各个装有虚拟机的平台运行  
### **JDK 和 JRE 的区别是什么？**
JRE是java运行环境，主要就是虚拟机  
JDK包括JRE、编译器和其他工具  
## **”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？**
static 和private编译时绑定成静态绑定：  
就是在编译期间就已经加载到了内存，包括private、static、final修饰的变量和方法，还有构造函数，都是静态绑定  
而覆盖是在运行时动态绑定的  
## **是否可以在static环境中访问非static变量？**
不可以 因为static在类加载时就初始化了，而此时非static的还没加载，会报错  
## **什么是自动拆装箱？**
自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。
## **Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？**  
Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。  
## **接口和抽象类的区别是什么？**
三个方面 关键字 方法  成员变量 其他  
**关键字**    
接口是对某一功能的抽象  关键字interface  无方法体（java9之后才有）implements后所有的方法必须实现   接口是最顶级的抽象 其变量只能是static final 即常量  
抽象类是对某一事物的抽象  关键字abstract  有方法体 有抽象和非抽象方法 extends后不一定要实现所有方法  抽象类可以是任意类型的变量   
类单继承 接口多实现    
## **双亲委派模型**
当类加载器需要加载class文件时会一层往一层去询问父类加载器能不能加载这个class文件，只有询问到最顶层父类后，才开始从父类往下找有能力加载该文件的加载器
## **forward和redirect的区别是什么？**
// 他们的区别如下：  
// 1. forward是服务器请求资源，服务器直接访问目标地址的URL，把URL的响应内容读取过来，然后把这些内容发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。  
// 2. redirect就是服务端根据逻辑发送一个状态码，告诉浏览器重新去请求事先访问过的那个地址，一般来说，浏览器会用刚才请求的所有参数重新请求，所以Session、Request参数都可以获取。  
## **JSP有哪些内置对象？作用分别是什么？**
// JSP共有9种基本内置组件（可与ASP的6种内部组件相对应）。  
// request：用户端请求，此请求会包含来自GET/POST请求的参数。  
// response：网页传回用户端的回应。  
// pageContent：网页的属性是在这里管理的。  
// Session：与请求有关的会话。  
// application：Servlet正在执行的内容。  
// Out：用来传送回应的输出。  
// COnfig：Servlet的构架部件。  
// Page：JSP网页本身。  
// Exception：针对错误网页，未 捕捉的例外。  
## **JSP有哪些动作？它们的作用分别是什么？**
// JSP共有以下6种基本动作。
// jsp:include： 在网页被请求的时候引入一个文件。
// jsp:userBean： 寻找或者实例化一个JavaBean。  
// jsp:setProperty： 设置JavaBean的属性。  
// jsp:getProperty： 输出某个JavaBean的属性。  
// jsp:forward： 把请求转到一个新的页面。  
// jsp:plugin： 根据浏览器类型为Java插件生成OBJECT或EMBED标记。  
## **JSP中动态INCLUDE与静态INCLUDE的区别有哪些？**
// 答案：动态INCLUED用jsp:include动作实现，如下面这行代码它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。

``` 
<jsp:include page="included.jsp" flush="true" />
```

静态INCLUDE用include伪码实现，如下面这行代码不会检查所包含文件的变化，适用于包含静态页面。  

``` 
<%@ include file="included.htm" %>
```

## **JSP两种跳转方式分别是什么？有什么区别？**
// 两种跳转方式分别如下。  

``` 
<jsp:include page="included.jsp" flush="true">
<jsp:forward page="nextpage.jsp" />
```

// 前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完以后还会回来，相当于函数调用，并且可以带参数。后者完全转向新页面，不会再回来，相当于GOTO语句。
## **使用JSP代码和使用JavaScript进行表单数据验证有什么不同？**  
// JavaScript为脚本程序，可以在表单提交前在客户端验证，提高了验证速度，不会使表单内信息丢失。JSP验证需要向服务器请求，服务器对请求页面进行重新编译，并验证数据的合法性，使得服务器负担加重，且验证结果返回较慢，容易使填写的表单信息丢失。
## **请描述Java Servlet API中forward()和rediect()的区别？**  
// 答案：前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址。后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其他服务器上的资源，则必须使用sendReditect()方法。  
## **请描述cookie和session机制的区别和联系。**  
// 1. 具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时，由于采用服务器端保持状态的方案在客户端也需要保存一个标志，所以session机制可能需要借助于cookie机制来达到保存标志的目的，但实际上它还有其他选择。  
// 2. 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的提示，以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本，如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于或等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。  
// 3. session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。  
// 4. 保存这个session ID的方式可以采用cookie，这样在交互过程中浏览器可以自动按照规则把这个标志发回给服务器。一般这个cookie的名字都是类似于session ID。但cookie可以被人为地禁止，则必须有其他机制，以便在cookie被禁止时仍能够把session ID传递回服务器。  
## **J2EE技术常见的面试题**  
## **Spring都有哪些特点？为什么要使用Spring？**    
### Spring的特点如下：  
// 1. Srping不同于其他的Framework，它要提供的是一种管理你业务对象的方法。  
// 2. Spring有分层的体系结构，意味着你能选择仅仅使用它的任何一个独立的部分，而其他的仍然使用你的相关实现。  
// 3. 它的设计从一开始就是要帮助你编写易于测试的代码，Spring是使用测试驱动开发（TDD）工程的理想框架。     
// 4. Spring不会给你的工程添加对其他的框架依赖，同时Spring又可以称得上是一个一揽子解决方案，提供了一个典型应用所需要的大部分基础架构。    
### 之所以要使用Spring，是因为：
// 1. Spring能有效地组织你的中间层对象。    
// 2. Spring能消除在许多工程中常见的对Singleton的过多使用。  
// 3. 通过一种在不同应用程序和项目间一致的方法来处理配置文件，消除各种自定义格式的属性文件的需要，仅仅需要看看类的JavaBean属性。Inversion of Control的使用帮助完成了这种简化。  
// 4. 能够很容易培养你面向接口而不是面向类的编程习惯。  
// 5. Spring的设计会让使用它创建的应用尽可能少地依赖于它的API，在Spring应用中的大多数业务对象没有依赖于Spring。  
// 6. 使用Spring构建的应用程序易于单元测试。  
// 7. Spring使EJB成为一个实现选择，而不是必需的选择。你可以用POJOs或local EJBs来实现业务接口，却不会影响到调用代码。  
// 8. Spring提供一些Web应用上的EJB的替代方案，比如用AOP提供声明性事务管理。  
// 9. Spring为数据存取提供了一个一致的框架，不论是使用JDBC还是O/R mapping的产品。  
### 需要注意的要点：  
// 1. 控制反转(Inverse of Control ,IOC)。 依赖注入(Dependency Injection, DI)。   
// 2. 控制反转是对组件对象控制权的转移，从程序代码本身转移到了外部容器，通过容器来实现对象组件的装配和管理  
// 3. 注入类型：接口注入、设置注入、构建子注入。而Spring则是IOC的一个容器。  
// 4. 在Spring中，所谓依赖注入，即在运行期由容器将依赖关系注入到组件之中，就是在运行期，由Spring根据配置文件，将其他对象的引用通过组件提供的Setter方法进行设定。  
// 5. 从核心而言，Spring是一个DI容器，其设计哲学是提供一种无侵入式的高扩展性框架，即无需代码中涉及Spring专有类，即可将其纳入Spring容器进行管理。  
// 6. 作为对比，EJB是一种高度侵入性的框架规范，它制定了众多的接口和编码规范，要求实现者必须遵从。为了实现无侵入性目标，Spring大量引入了Java的Reflection机制，通过动态调用的方式避免硬编码方式的约束，并在此基础上建立了其核心组件BeanFactory，以此作为其依赖注入机制的实现基础。  
// 7. org.springframework.beans包中包括了这些核心组件的实现类，核心中的核心为BeanWrapper和BeanFactory类。  
// 8. Spring的主要目的就是使J2EE易用和促进良好的编程习惯。  
// 9. Spring是让已有的技术更加易用。比如，它没有底层事务协调处理，但是提供了一个抽象层覆盖了JTA和任何其他事务策略。Spring并没有和其他的开源项目竞争，不过还是在一些领域有新的方案提供，比如它的Web Framework、轻量级的IoC容器和AOP框架。  
## **Hibernate的工作原理是什么？为什么要使用Hibernate？**  
### Hibernate工作原理如下  
// 1. 读取并解析配置文件。  
// 2. 读取并解析映射信息，创 建SessionFactory。  
// 3. 打开Session。  
// 4. 创建事务Transaction。  
// 5. 持久化操作。  
// 6. 提交事务。  
// 7. 关闭Session。  
// 8. 关闭SessionFactory。  
### **使用hibernate的原因如下**  
// 1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层烦琐的重复性代码。  
// 2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它在很大程度上简化了DAO层的编码工作。  
// 3. Hibernate使用Java反射机制，而不是字节码增强程序类实现透明性。  
// 4. Hibernate的性能非常好，以为它是一个轻量级框架，映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。  
## **Hibernate中使用二级缓存时要注意什么？**  
Hibernate中使用二级缓存时要注意的几点如下。  
// 1. 二级缓存能够明显提高系统的性能，当然，如果数据量特别巨大，此时不适合于二级缓存，原因是缓存的数据量过大可能会引起内存资源紧张，反而降低性能。  
// 2. 对于数据更新频率过高的数据，频繁地同步缓存中数据的代码可能和查询缓存中的数据从中获得的好处相当，坏处和益处相抵消，此时缓存的意义也不大。  
// 3. 财务数据等非常重要的数据，绝对不允许出现或使用无效的数据，所以此时为了安全起见，最好不要使用二级缓存。以为此时“正确性”的重要性远远大于“高性能”的重要性。  
// 4. 因为数据表中的数据量虽然大，但经常使用的往往只是较新的那部分数据，此时，也可为其配置二级缓存。但是必须单独配置其持久化类的缓存策略，比如最大缓存数、缓存过期时间等，将这些参数降低至一个合理的范围（太高会引起内存资源紧张，太低了则缓存的意义不大），同时也会消耗更多的内存，可以通过配置文件来指定内存中能够加载的最多元素，这有利于消耗过多的内存。  
## **Hibernate二级缓存的注意要点**  
// 1. Hibernate中对于Cache有一级缓存和二级缓存 的概念，一级缓存是必需的，位于Session部分，二级缓存则不是必需的，是由SessionFactory控制的进行级缓存，由开发人员制定。  
// 2. 二级缓存可指定使用何种开源的Cache工具，Hibernate 3以后的版本默认使用的是Ehcache，也可以切换为Oscache、JbossCache.  
// 3. Hibernate查询时使用的还行过程如下：1>. 查询一级缓存中是否具有需要的数据；2>. 如果没有，查询二级缓存；3>. 如果二级缓存中也没有，此时再执行查询数据库的工作。此三种方式的查询速度依次降低。  
// 4. Hibernate会自行维护缓存中的数据，以保证缓存中的数据和数据库中的真实数据的一致性。  
// 5. 无论何时，当你调用方法传递或获得一个对象时，该对象都将被加入到Session的内部缓存中。当flush()方法随后被调用时，对象的状态会和数据库取得同步。也就是说，删除、更新、增加数据的时候，同时更新换成。  
## **Hibernate有哪些主键？**  
// Hibernate有如下主键，Hilo，Increment，Identity，Sequence，Native，UUID，Foreign GUID。  
// Hibernate主键的注意要点如下：  
// 1. Hilo。Hilo使用高低位算法生成主键。Hilo方式需要额外的数据库表和字段提供高位值来源。Hilo方式与底层数据库无关，但不应该手动修改hilo算法使用的表值，否则会引起主键重复的异常。  
// 2. Increment。Increment方式对主键值采取自动增长的方式生成新的主键值，但要求底层数据库支持Sequence方式，如Orcale、DB2等。特定是由Hibernate本身维护，适用于所有的数据库，不适合多进行并发更新数据库，适合单一进程访问数据库，不能用于群集环境。  
// 3. Identity。Identity根据底层数据库来支持自动增长，不同的数据库用不同的主键增长方式。特点是与底层数据库有关，要求数据库支持identity，如MySQL中的auto_increment，SQL Server中的Identity,支持的数据库有MySQL、SQL Server、DB2、Sybase和HypersonicSQL。Identity无效Hibernate和用户的干涉，使用较为方便，但不便于在不同的数据库之间移植程序。  
// 4. Sequence。Sequence需要底层数据库支持Sequence方式，例如Orcale数据库等。特点是需要底层数据库支持序列，支持序列的数据库有DB2，PostgreSql、Orcale、SAPDb等。  
// 5. Native。Native主键生成方式会根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式。特点是根据不同的底层数据库采用各不同的主键生成方式。因此，便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。  
// 6. UUID。UUID使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性。特点是能够保证数据库中主键的唯一性，生成的注解占用比较多的存储空间。  
// 7. Foreign GUID。Foreign用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证主键的唯一性，支持SQL Server和MySQL。  
## **Hibernate有几种查询数据的方式？**  
// Hibernate有3中查询方式。  
// 1. HQL: Hibernate Query Language,它根SQL非常类似  
// 2. Criteria Query,以对象的方式添加查询条件  
// 3. SQL,直接使用SQL语句操作数据库。  
## **如果让你设计一个数据库连接池，你可能会考虑到哪些方面的问题？**  
// 可以考虑如下方面的问题：  
// 1. 连接池需要实现javax.sql.DataSource接口，以适应于不同的场合。  
// 2. Connection#close 问题，使用者使用连接池与不使用连接池，除了从哪获得Connection对象不一样之外，其他JDBC的代码是完全相同的，并不能因为使用连接池而改变既有的JDBC代码。如果不能改变JDBC代码，就带来了一个Connection close问题，大家都知道这个调用是关闭数据库连接，如果在连接池中这么做的话就会关闭连接，使用连接得不到重用。  
// 3. 连接被动关闭问题。为了保证连接的复用性，将连接一直保存在池中。有些数据库服务器会将已经连接很久的客户端连接主动踢掉，如果碰到这种情况，在池中的这个连接池就会变为不可用状态，如果客户端使用的话将会抛出连接被关闭的SQLException。  
// 4. 连接回收问题。假如我们的连接池最大设为50个，在某一并发很高的时段达到了50个，但是过后并发率就降下去了，对于连接池来说池中还是50个连接，实际上后面根本不需要那么多连接。这时连接池白白地浪费了几十个数据库宝贵的连接（数据库对于客户端的连接数是有限制的），如果连接池占用了很多的连接，那么可能会导致其他应用程序因为数据库客户端的连接到了限制而无法再获得连接。我们应该及时地将不需要使用的连接关闭还给数据库服务器，保留一些基本连接数。  
// 5. 网络中断重连问题。连接池中的连接在网络中断时，池中连接会全部断开，数据库服务器也会回收断开的连接。但是网络中断后，过了一些时间又连上了，这时池中的连接依然是断开的，如果取出来用的话，不用说就会抛出异常的。一个可用的连接需要有实现自动重连的功能，否则就没有可用的价值。  
## **在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？**  
// 答案如下：  
// 1. 在阻塞模式下，若从网络中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，后面已经有10个字节的数据发过来，但是假如现在只收到8个字节，那么当前线程就在那傻傻地等待下一个字节的到来，直到把这10个字节读取完，这才将阻塞放开通行。  
// 2. 在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，后面已经有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节来的时候再去读取。  
// 3. 从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停的东奔西跑，直接到把数据接收完了。  
// 4. 虽然说，非阻塞IO比阻塞IO有更高的性能，但是对于开发来说，难度就成数倍递增了。由于是有多少数据就读取多少数据，这样在读取完整之前需要将已经读取到的数据保存起来，而且需要与其他地方来的数据隔离开来不能混在一起，否则就不知道这数据是谁的了。  

下面都是我自己的答案非官方，仅供参考，如果有疑问或错误请一定要提出来，大家一起进步啦~~~
1. 下面哪些是Thread类的方法（）
A start()       B run()       C exit()       D getPriority()
答案：ABD
解析：看Java API docs吧：http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。
2. 下面关于java.lang.Exception类的说法正确的是（）
A 继承自Throwable      B Serialable      CD 不记得，反正不正确
答案：A
解析：Java异常的基类为java.lang.Throwable，java.lang.Error和java.lang.Exception继承 Throwable，RuntimeException和其它的Exception等继承Exception，具体的RuntimeException继承RuntimeException。 
扩展：错误和异常的区别(Error vs Exception) 
1) java.lang.Error: Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。
java.lang.Exception: Throwable的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。
2)  Error和RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的Exception类都是检查了的异常（checked exceptions）.
checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException, ParseException等。检查了的异常发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。
unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。
RuntimeException：RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等。
处理RuntimeException的原则是：如果出现 RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。其他（IOException等等）checked异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。 
3. 下面程序的运行结果是（）
String str1 = "hello";
String str2 = "he" + new String("llo");
System.err.println(str1 == str2);
答案：false
解析：因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。如果是String str2 = str1，那么就是true了。
4. 下列说法正确的有（）
A． class中的constructor不可省略
B． constructor必须与class同名，但方法不能与class同名
C． constructor在一个对象被new时执行
D．一个class只能定义一个constructor
答案：C 
解析：这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。
5. 具体选项不记得，但用到的知识如下：  
String []a = new String[10];  
则：a[0]~a[9] = null  
a.length = 10  
如果是int []a = new int[10];  
则：a[0]~a[9] = 0  
a.length = 10  
6. 下面程序的运行结果：（）  
``` 
public static void main(String args[]) {
        Thread t = new Thread() {
            public void run() {
                pong();
            }
        };
        t.run();
        System.out.print("ping");
    }
    static void pong() {
        System.out.print("pong");
    }
```
A pingpong        B pongping       C pingpong和pongping都有可能       D 都不输出  
答案：B  
解析：这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程，进而调用run()方法来执行任务，而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使用start()而不是run()。  
7. 下列属于关系型数据库的是（）
A. Oracle    B MySql    C IMS     D MongoDB
答案：AB
解答：IMS（Information Management System ）数据库是IBM公司开发的两种数据库类型之一; 
一种是关系数据库，典型代表产品：DB2；
另一种则是层次数据库，代表产品：IMS层次数据库。
非关系型数据库有MongoDB、memcachedb、Redis等。
8. GC线程是否为守护线程？（）
答案：是
解析：线程分为守护线程和非守护线程（即用户线程）。
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
守护线程最典型的应用就是 GC (垃圾回收器)
9. volatile关键字是否能保证线程安全？（）
答案：不能
解析：volatile关键字用在多线程同步中，可保证读取的可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的读取值，而非cache中。但多个线程对
volatile的写操作，无法保证线程安全。例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值，在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6；线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6；导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。
10. 下列说法正确的是（）
A LinkedList继承自List
B AbstractSet继承自Set
C HashSet继承自AbstractSet
D WeakMap继承自HashMap
答案：AC
解析：下面是一张下载的Java中的集合类型的继承关系图，一目了然。
11. 存在使i + 1 < i的数吗（）

答案：存在
解析：如果i为int型，那么当i为int能表示的最大整数时，i+1就溢出变成负数了，此时不就<i了吗。
扩展：存在使i > j || i <= j不成立的数吗（）
答案：存在
解析：比如Double.NaN或Float.NaN，感谢@BuilderQiu网友指出。
12. 0.6332的数据类型是（）
A float     B double     C Float      D Double
答案：B
解析：默认为double型，如果为float型需要加上f显示说明，即0.6332f
13. 下面哪个流类属于面向字符的输入流(  )
A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader
 答案：D
 解析：Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。
 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。
 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。
总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；
          以Reader（输入）/Writer（输出）为后缀的是字符流。
扩展：Java流类图结构，一目了然，解决大部分选择题：
14. Java接口的修饰符可以为（）
A private     B protected     C final       D abstract
答案：CD
解析：接口很重要，为了说明情况，这里稍微啰嗦点：
（1）接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；
（2）接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；
（3）接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量；
（4）接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。
（5） 接口中不可以定义变量？如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过 实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中 不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统 一的属性。
通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，接口是对开闭原则的一种体现。
所以：
接口的方法默认是public abstract；
接口中不可以定义变量即只能定义常量(加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。
注意：final和abstract不能同时出现。
15. 不通过构造函数也能创建对象吗（）
A 是     B 否
答案：A
解析：Java创建对象的几种方式（重要）：
(1) 用new语句创建对象，这是最常见的创建对象的方法。
(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
(3) 调用对象的clone()方法。
(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。
(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。
16. ArrayList list = new ArrayList(20);中的list扩充几次（）
A 0     B 1     C 2      D 3
答案：A
解析：这里有点迷惑人，大家都知道默认ArrayList的长度是10个，所以如果你要往list里添加20个元素肯定要扩充一次（扩充为原来的1.5倍），但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，也就是不需要扩充了。
17. 下面哪些是对称加密算法（）
A DES   B AES   C DSA   D RSA
答案：AB
解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES
常用的非对称加密算法有：RSA、DSA、ECC
使用单向散列函数的加密算法：MD5、SHA
18.新建一个流对象，下面哪个选项的代码是错误的？（）
A）new BufferedWriter(new FileWriter("a.txt"));
B）new BufferedReader(new FileInputStream("a.dat"));
C）new GZIPOutputStream(new FileOutputStream("a.zip"));
D）new ObjectInputStream(new FileInputStream("a.dat"));
答案：B
解析：请记得13题的那个图吗？Reader只能用FileReader进行实例化。
19. 下面程序能正常运行吗（）
``` 
public class NULL {
    public static void haha(){
        System.out.println("haha");
    }
    public static void main(String[] args) {
        ((NULL)null).haha();
    }
}
```
答案：能正常运行
解析：输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。这里和C++很类似。这里感谢@Florian网友解答。
20. 下面程序的运行结果是什么（）
``` 
class HelloA {
    public HelloA() {
        System.out.println("HelloA");
    }
    { System.out.println("I'm A class"); }
    static { System.out.println("static A"); }
}
public class HelloB extends HelloA {
    public HelloB() {
        System.out.println("HelloB");
    }    
    { System.out.println("I'm B class"); }    
    static { System.out.println("static B"); }    
    public static void main(String[] args) { 
　　　　 new HelloB(); 
　　 }
}
```
答案：
static A
static B
I'm A class
HelloA
I'm B class
HelloB
解析：说实话我觉得这题很好，考查静态语句块、构造语句块（就是只有大括号的那块）以及构造函数的执行顺序。
对象的初始化顺序：（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；（2）当static语句执行完之后,再执行main方法；（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。
下面稍微修改下上面的代码，以便更清晰的说明情况：
View Code 
此时输出结果为：
``` 
static A
static B
-------main start-------
I'm A class
HelloA
I'm B class
HelloB
I'm A class
HelloA
I'm B class
HelloB
-------main end-------
```
21. getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（）
``` 
    public void getCustomerInfo() {
        try {
            // do something that may cause an Exception
        } catch (java.io.FileNotFoundException ex) {
            System.out.print("FileNotFoundException!");
        } catch (java.io.IOException ex) {
            System.out.print("IOException!");
        } catch (java.lang.Exception ex) {
            System.out.print("Exception!");
        }
    }
```
A IOException!
BIOException!Exception!
CFileNotFoundException!IOException!
DFileNotFoundException!IOException!Exception!
答案：A
解析：考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。
22. 下面代码的运行结果为：（）
``` 
import java.io.*;
import java.util.*;
public class foo{
    public static void main (String[] args){
        String s;
        System.out.println("s=" + s);
    }
}
```
A 代码得到编译，并输出“s=”
B 代码得到编译，并输出“s=null”
C 由于String s没有初始化，代码不能编译通过
D 代码得到编译，但捕获到 NullPointException异常
答案：C
解析：开始以为会输出null什么的，运行后才发现Java中所有定义的基本类型或对象都必须初始化才能输出值。
23.  System.out.println("5" + 2);的输出结果应该是（）。
A 52                   B7                     C2                     D5
答案：A
解析：没啥好说的，Java会自动将2转换为字符串。
24. 指出下列程序运行的结果 （）
``` 
public class Example {
    String str = new String("good");
    char[] ch = { 'a', 'b', 'c' };
    public static void main(String args[]) {
        Example ex = new Example();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.print(ex.ch);
    }
    public void change(String str, char ch[]) {
        str = "test ok";
        ch[0] = 'g';
    }
}
```
A、 good and abc
B、 good and gbc
C、 test ok and abc
D、 test ok and gbc 
答案：B
解析：大家可能以为Java中String和数组都是对象所以肯定是对象引用，然后就会选D，其实这是个很大的误区：因为在java里没有引用传递，只有值传递
这个值指的是实参的地址的拷贝，得到这个拷贝地址后，你可以通过它修改这个地址的内容（引用不变），因为此时这个内容的地址和原地址是同一地址，
但是你不能改变这个地址本身使其重新引用其它的对象，也就是值传递，可能说的不是很清楚，下面给出一个完整的能说明情况的例子吧：
程序有些啰嗦，但能反映问题，该程序运行结果为：
``` 
对象交换前：p1 = Alexia female
对象交换前：p2 = Edward male

对象交换后：p1 = Alexia female
对象交换后：p2 = Edward male

对象数组交换前：arraya[0] = Alexia female, arraya[1] = Edward male
对象数组交换前：arrayb[0] = jmwang female, arrayb[1] = hwu male

对象数组交换后：arraya[0] = Alexia female, arraya[1] = Edward male
对象数组交换后：arrayb[0] = jmwang female, arrayb[1] = hwu male

基本类型数组交换前：a[0] = 0, a[1] = 1
基本类型数组交换前：b[0] = 1, b[1] = 2

基本类型数组交换后：a[0] = 0, a[1] = 1
基本类型数组交换后：b[0] = 1, b[1] = 2

对象数组内容交换并改变后：arraya[1] = wjl male
对象数组内容交换并改变后：arrayb[1] = Edward male

基本类型数组内容交换并改变后：a[1] = 5
基本类型数组内容交换并改变后：b[1] = 1
```
说明：不管是对象、基本类型还是对象数组、基本类型数组，在函数中都不能改变其实际地址但能改变其中的内容。
25. 要从文件"file.dat"中读出第10个字节到变量c中,下列哪个方法适合? （）
A FileInputStream in=new FileInputStream("file.dat"); in.skip(9); int c=in.read();
B FileInputStream in=new FileInputStream("file.dat"); in.skip(10); int c=in.read();
C FileInputStream in=new FileInputStream("file.dat"); int c=in.read();
D RandomAccessFile in=new RandomAccessFile("file.dat"); in.skip(9); int c=in.readByte();
答案：A?D?
解析：long skip(long n)作用是跳过n个字节不读，主要用在包装流中的，因为一般流（如FileInputStream）只能顺序一个一个的读不能跳跃读，但是包装流可以用skip方法跳跃读取。那么什么是包装流呢？各种字节节点流类，它们都只具有读写字节内容的方法，以FileInputStream与FileOutputStream为例，它们只能在文件中读取或者向文件中写入字节，在实际应用中我们往往需要在文件中读取或者写入各种类型的数据，就必须先将其他类型的数据转换成字节数组后写入文件，或者从文件中读取到的字节数组转换成其他数据类型，想想都很麻烦！！因此想通过FileOutputStream将一个浮点小数写入到文件中或将一个整数写入到文件时是非常困难的。这时就需要包装类DataInputStream/DataOutputStream，它提供了往各种输入输出流对象中读入或写入各种类型的数据的方法。
DataInputStream/DataOutputStream并没有对应到任何具体的流设备，一定要给它传递一个对应具体流设备的输入或输出流对象，完成类似 DataInputStream/DataOutputStream功能的类就是一个包装类，也叫过滤流类或处理流类。它对InputOutStream/OutputStream流类进行了包装，使编程人员使用起来更方便。其中DataInputStream包装类的构造函数语法：public DataInputStream(InputStream in)。包装类也可以包装另外一个包装类。
首先BC肯定 是错的，那A正确吗？按上面的解析应该也不对，但我试了下，发现A也是正确的，与网上解析的资料有些出入，下面是我的code：
那么D呢，RandomAccessFile是IO包的类，但是其自成一派，从Object直接继承而来。可以对文件进行读取和写入。支持文件的随机访问，即可以随机读取文件中的某个位置内容，这么说RandomAccessFile肯定可以达到题目的要求，但是选项有些错误，比如RandomAccessFile的初始化是两个参数而非一个参数，采用的跳跃读取方法是skipBytes()而非skip()，即正确的写法是：
RandomAccessFile in = new RandomAccessFile("file.dat", "r");
in.skipBytes(9);
int c = in.readByte();
这样也能读到第十个字节，也就是A和D都能读到第十个字节，那么到底该选哪个呢？A和D有啥不同吗？求大神解答~~~
26. 下列哪种异常是检查型异常，需要在编写程序时声明 （）
ANullPointerException        BClassCastException      CFileNotFoundException       D IndexOutOfBoundsException 
答案：C
解析：看第2题的解析。
27. 下面的方法，当输入为2的时候返回值是多少?（）
``` 
    public static int getValue(int i) {
        int result = 0;
        switch (i) {
        case 1:
            result = result + i;
        case 2:
            result = result + i * 2;
        case 3:
            result = result + i * 3;
        }
        return result;
    }
```
A0                    B2                    C4                     D10
答案：D
解析：注意这里case后面没有加break，所以从case 2开始一直往下运行。
28. 选项中哪一行代码可以替换题目中//add code here而不产生编译错误？（）
``` 
public abstract class MyClass {
     public int constInt = 5;
     //add code here
     public void method() {
     }
}
```
Apublic abstract void method(int a);
B constInt = constInt + 5;
C public int method();
D public abstract void anotherMethod() {}
答案：A
解析：考察抽象类的使用。
抽象类遵循的原则：
（1）abstract关键字只能修饰类和方法，不能修饰字段。
（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。
（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。
（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。
（5）含有抽象方法的类必须定义成抽象类。
扩展：抽象类和接口的区别，做个总结吧：
（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。
（2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。
（3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。
（4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"has-a"关系。
（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。
（6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。
29. 阅读Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ (  )
``` 
class Shape {
       public String name;
}
class Circle extends Shape implements Serializable{
       private float radius;
       transient int color;
       public static String type = "Circle";
}
```
Aname
B radius
C color
D type
答案：B
解析：这里有详细的解释：http://www.cnblogs.com/lanxuezaipiao/p/3369962.html
30.下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child("mike")的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )
``` 
class People {
    String name;
    public People() {
        System.out.print(1);
    }
    public People(String name) {
        System.out.print(2);
        this.name = name;
    }
}
class Child extends People {
    People father;
    public Child(String name) {
        System.out.print(3);
        this.name = name;
        father = new People(name + ":F");
    }
    public Child() {
        System.out.print(4);
    }
}
```
A312              B 32               C 432              D 132
答案：D
解析：考察的又是父类与子类的构造函数调用次序。在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？
第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。    
第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。
总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。
最后，给大家出个思考题：下面程序的运行结果是什么？
``` 
public class Dervied extends Base {
    private String name = "dervied";
    public Dervied() {
        tellName();
        printName();
    }
    public void tellName() {
        System.out.println("Dervied tell name: " + name);
    }    
    public void printName() {
        System.out.println("Dervied print name: " + name);
    }
    public static void main(String[] args){
        
        new Dervied();    
    }
}
class Base {    
    private String name = "base";
    public Base() {
        tellName();
        printName();
    }   
    public void tellName() {
        System.out.println("Base tell name: " + name);
    }    
    public void printName() {
        System.out.println("Base print name: " + name);
    }
}

```